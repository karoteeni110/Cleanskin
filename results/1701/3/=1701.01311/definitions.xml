<?xml version="1.0" encoding="UTF-8"?>
<opml version="2.0">
  <head>
    <title></title>
    <abstract> </abstract>
  </head>
  <body>
<outline text="CSCN Problem’s NP-Completeness" _note="We have formalized the problem of the Core Structural Connectivity Network taking into account the density and connectedness of the core subgraph and the sparsity of the outer one. We will now prove that, with this formalization, the problem is -Complete.  Given weighted graphs (the SAMPLE GRAPHS) with a common node set, a complete edges set () and weights of their edges, and given real numbers, find connected graph (the CORE GRAPH) such that for and as defined in Eq. ( ) and Eq .( ).  In Theorem   we have proved that  is -complete. Hence, to be able to solve it in reasonable time we need a relaxation to make it tractable or an approximate algorithm for the complete version. In this article we will propose both.">
</outline>
<outline text="Relaxation of the CSCN problem" _note="We proved in the previous section that the connectivity constraint is the main reason of the difficulty of the problem. Without it, it becomes tractable. So we solve, in this section, a relaxed version of problem without the connectivity constraint. Then, we use this solution to approximate the full problem.  The decision version of  without the connectivity constraint is in ¶.  Compute for each  Algorithm  , in each step , defines as the maximum weighted edges and tries to use that to fulfill the constraints.  Assume that there exists an that fulfills the constraints. There are two cases: 1) has the maximum weighted edges, 2) there are , such that . In 1), Algorithm   will find . In 2), let another subset of . Then because the edges in are the same as the ones in except from one that has a larger weight. For the same reason, Thus, we found a new subset of that stills fulfills the constraints. We can do the same process with (replace an edge with another one of larger weight) iteratively, always getting subsets that fulfills the constraints, until we cannot do this anymore. At that point we will have a subset that has only the maximum edges and fulfills the constraints. Thus, algorithm   will find this subset.  We now need to prove algorithm   runs in polynomial time in the size of . The first operation, computing for each , implies computing the mean and standard deviation for each edge across the population, which can be done in per edge (where is the size of the population). This is for all the edges. The second step, sorting, can be done in .  The main loop runs at most times, and in each loop it adds an edge to , computes and and performs two comparisons. The comparisons can be done in constant time, as the addition to if we use a linked list of edges to represent it. To compute and it is needed to iterate once again (the part in for , the part in for ) adding the weights together and then performing two divisions. This can be done in linear time in the size of , and even quicker (constant time) if we optimize it by keeping the values of and across loops and updating them with the weight of the edge that changed sets.  Then, algorithm   solves the  in or in if a little optimization is used.">
</outline>
<outline text="Heuristic approach" _note="In Section   we developed Algorithm   to solve the problem of finding the Core Structural Connectivity Network in polynomial time. However, this algorithm does not guarantee a connected result. We solve the original problem, presented in Section  , by first applying Algorithm   and then modifying the resulting core graph to guarantee its connectedness. This results in an approximate solution for the full problem computable in polynomial time.  To extend into a connected graph we add the necessary edges while decreasing the minimum possible the objective function defined in Eq.  . For this, we use the same approach that Wassermann et al. . Namely, we make a multigraph with the connected components of as nodes, complete it with all the possible edges between those connected components, and run a Maximum Spanning Tree algorithm. This selects the edges needed to produce a connected subgraph with the maximum possible weight. For the full details, see Wassermann et al. . This way we get a connected subgraph close to the best possible subgraph, which we obtained using Algorithm  .">
</outline>
  </body>
</opml>