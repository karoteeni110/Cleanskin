<?xml version="1.0" encoding="UTF-8"?>
<opml version="2.0">
  <head>
    <title>**Computable Isomorphisms for Certain Classes of Infinite Graphs**</title>
    <abstract>We investigate (2,1):1 structures, which consist of a countable set
together with a function such that for every element in , maps either
exactly one element or exactly two elements of to . These structures
extend the notions of injection structures, 2:1 structures, and (2,0):1
structures studied by Cenzer, Harizanov, and Remmel, all of which can be
thought of as infinite directed graphs. We look at various
computability-theoretic properties of (2,1):1 structures, most notably
that of computable categoricity. We say that a structure is computably
categorical if there exists a computable isomorphism between any two
computable copies of . We give a sufficient condition under which a
(2,1):1 structure is computably categorical, and present some examples
of (2,1):1 structures with different computability-theoretic properties. </abstract>
  </head>
  <body>
<outline text="Introduction" _note="In computable model theory, we study the properties of classical mathematical structures from the perspective of computability theory. A set is COMPUTABLE if there is a Turing program, or more generally, an algorithm, that can decide the membership of . Furthermore, a set is COMPUTABLY ENUMERABLE if there is an algorithm to enumerate the elements of . A countable structure over a finite language is COMPUTABLE if its domain is computable and all of its functions and relations are computable. Unless otherwise specified, all of our structures are computable, and we assume that their domain is , the set of natural numbers.  One of the key concepts in computable model theory is that of computable isomorphisms between structures. We say that two computable structures and that are isomorphic to each other are COMPUTABLY ISOMORPHIC if there exists a computable function , where is an isomorphism from to . Computable isomorphisms preserve not only the functions and relations of a structure, but also the algorithmic properties of the structure. It is very possible for two isomorphic computable structures to not be COMPUTABLY isomorphic. Thus, we have the following definition.\  A computable structure is COMPUTABLY CATEGORICAL if every two computable isomorphic copies of are computably isomorphic.  We seek to classify computable structures up to computable isomorphism. That is, within a class of structures, we wish to provide characterizations of those computable structures that are computably categorical. This has been done for various classes of mathematical structures. For example, Goncharov and Dzgoev , and independently Remmel , proved that a computable linear order is computably categorical if and only if it has only finitely many successor pairs. Additionally, Goncharov and Dzgoev , LaRoche , and Remmel independently proved that a computable Boolean algebra is computably categorical if and only if it has only finitely many atoms. Goncharov, Lempp, and Solomon characterized computably categorical ordered abelian groups as those with finite rank. In , Calvert, Cenzer, Harizanov, and Morozov gave a characterization of computably categorical equivalence structures (structures consisting of a countable set and an equivalence relation).  Computable categoricity has also been extensively studied for certain types of graphs. Lempp, McCoy, Miller, and Solomon characterized computable trees of finite height that are computably categorical, and Miller previously showed that no computable tree of infinite height is computably categorical. In , Csima, Khoussainov, and Liu investigated computable categoricity of STRONGLY LOCALLY FINITE GRAPHS, those which have countably many finite connected components, by looking at proper embeddability of the components. As an example, it can be shown that the first graph in Figure 1 is computably categorical, whereas the second graph is not.  (A”) at (0,0.7)  ; (B”) at (0.5,0.7)  ; (C”) at (1,0.7)  ; (D”) at (1.5,0.7)  ; (E”) at (2,0.7)  ; (F”) at (2.5,0.7)  ; (G”) at (3,0.7)  ; (H”) at (3.5,0.7)  ; (I”) at (4,0.7)  ; (J”) at (4.5,0.7)  ; (K”) at (5,0.7)  ; (L”) at (5.5,0.7)  ; (M”) at (6,0.7)  ; (N”) at (6.5,0.7)  ; (O”) at (7,0.7)  ; (P”) at (7.5,0.7)  ; at (8,0.7) []{}; at (-3.33,0.7) ;  (A”) to (B”); (C”) to (D”); (E”) to (F”); (G”) to (H”); (I”) to (J”); (K”) to (L”); (M”) to (N”); (O”) to (P”);  (A’) at (0,0)  ; (B’) at (0.5,0)  ; (C’) at (1,0)  ; (D’) at (1.5,0)  ; (E’) at (2,0)  ; (F’) at (2.5,0)  ; (G’) at (3,0)  ; (H’) at (3.5,0)  ; (I’) at (4,0)  ; (J’) at (4.5,0)  ; (K’) at (5,0)  ; (L’) at (5.5,0)  ; (M’) at (6,0)  ; (N’) at (6.5,0)  ; (O’) at (7,0)  ; (P’) at (7.5,0)  ; at (8,0) []{}; at (-3,0) ;  (B’) to (C’); (D’) to (E’); (E’) to (F’); (G’) to (H’); (H’) to (I’); (I’) to (J’); (K’) to (L’); (L’) to (M’); (M’) to (N’); (N’) to (O’);  We are interested in classes of infinite directed graphs that are derived from computable functions. Cenzer, Harizanov, and Remmel first studied directed graphs of this type in , where they defined injection structures. An INJECTION STRUCTURE is a countable set together with an injective function . An injection structure can be completely classified up to isomorphism by the number, type, and size of its ORBITS, which are the types of connected components the structure may have.  \(A) at (-1.5,1)  ; (B) at (-0.5,1)  ; (C) at (0.5,1)  ; (D) at (1.5,1)  ; at (2.3,1) []{}; at (-5,1) ;  \(A) to (B); (B) to (C); (C) to (D); (D) to (2,1);  (A’) at (-2,0)  ; (B’) at (-1,0)  ; (C’) at (0,0)  ; (D’) at (1,0)  ; (E’) at (2,0)  ; at (2.8,0) []{}; at (-2.8,0) []{}; at (-5,0) ;  (A’) to (B’); (B’) to (C’); (C’) to (D’); (D’) to (E’); (E’) to (2.5,0); (-2.5,0) to (A’);  (A”) at (-1,-1)  ; (B”) at (0,-1)  ; (C”) at (1,-1)  ; at (-5,-1) ;  (A”) to (B”); (B”) to (C”); (C”) to   (A”);  Cenzer, Harizanov, and Remmel obtained the following characterization theorem for injection structures.  A computable injection structure is computably categorical if and only if has only finitely many infinite orbits, that is, only finitely many -orbits and only finitely many -orbits.  Next, Cenzer, Harizanov, and Remmel looked at TWO-TO-ONE (2:1) STRUCTURES , where for all , as well as (2,0):1 STRUCTURES , where for all . Here, denotes the cardinality of the set . Thus, in a 2:1 structure, every element has exactly two pre-images under , and in a (2,0):1 structure, every element has either exactly two pre-images or no pre-image under . The types of orbits for these structures are shown below.  at (3.7,2.5) [\*]{}; (A) at (0,0.5) ; (B) at (0.5,0); (C) at (0,-0.5) ; (D) at (-0.5,0) ; (A1) at (0,1); (B1) at (1,0); (C1) at (0, -1); (D1) at (-1,0); at (0, 1.5); at (1.5, 0); at (0, -1.5); at (-1.5, 0); at (0,2) ;  \(A) to   (B); (B) to   (C); (C) to   (D); (D) to   (A);  (A1) to (A); (-0.5, 1.75) to (A1); (0.5,1.75) to (A1); (-0.5,1.75) to (0.5,1.75);  (B1) to (B); (1.75, -0.5) to (B1); (1.75, 0.5) to (B1); (1.75, 0.5) to (1.75, -0.5);  (C1) to (C); (-0.5,-1.75) to (C1); (0.5,-1.75) to (C1); (-0.5,-1.75) to (0.5,-1.75);  (D1) to (D); (-1.75, -0.5) to (D1); (-1.75,0.5) to (D1); (-1.75,-0.5) to (-1.75,0.5);  \(E) at (4,1); (F) at (5.5,1); (G) at (7,1); at (7.8,1)[]{}; at (3.2,1) []{}; (E1) at (4,0.5); (F1) at (5.5,0.5); (G1) at (7,0.5); at (4, 0); at (5.5, 0); at (7, 0); at (5.5,2) ;  \(E) to (F); (F) to (G); (E1) to (E); (F1) to (F); (G1) to (G); (G) to (7.5,1); (3.5,1) to (E); (3.5,-.25) to (E1); (4.5,-.25) to (E1); (3.5,-.25) to (4.5,-.25);  (5,-.25) to (F1); (6,-.25) to (F1); (5,-.25) to (6,-.25);  (6.5,-.25) to (G1); (7.5,-.25) to (G1); (6.5,-.25) to (7.5,-.25);  at (5.78,-1) ; at (4.23, -1.5) ;  at (3.7,2.5) [\*]{}; (A) at (0,0.5) ; (B) at (0.5,0); (C) at (0,-0.5) ; (D) at (-0.5,0) ; (A1) at (0,1); (B1) at (1,0); (C1) at (0, -1); (D1) at (-1,0); at (0, 1.5); at (1.5, 0); at (0, -1.5); at (-1.5, 0); at (0,2) ;  \(A) to   (B); (B) to   (C); (C) to   (D); (D) to   (A);  (A1) to (A); (-0.5, 1.75) to (A1); (0.5,1.75) to (A1); (-0.5,1.75) to (0.5,1.75);  (B1) to (B); (1.75, -0.5) to (B1); (1.75, 0.5) to (B1); (1.75, 0.5) to (1.75, -0.5);  (C1) to (C); (-0.5,-1.75) to (C1); (0.5,-1.75) to (C1); (-0.5,-1.75) to (0.5,-1.75);  (D1) to (D); (-1.75, -0.5) to (D1); (-1.75,0.5) to (D1); (-1.75,-0.5) to (-1.75,0.5);  \(E) at (4,1.75); (F) at (5.5,1.75); (G) at (7,1.75); at (7.8,1.75)[]{}; at (3.2,1.75) []{}; (E1) at (4,1.25); (F1) at (5.5,1.25); (G1) at (7,1.25); at (4.05, 0.70); at (5.5, 0.75); at (7, 0.75); at (5.5,2) ;  \(E) to (F); (F) to (G); (E1) to (E); (F1) to (F); (G1) to (G); (G) to (7.5,1.75); (3.5,1.75) to (E); (3.5,0.5) to (E1); (4.5,0.5) to (E1); (3.5,0.5) to (4.5,0.5);  (5,0.5) to (F1); (6,0.5) to (F1); (5,0.5) to (6,0.5);  (6.5,0.5) to (G1); (7.5,0.5) to (G1); (6.5,0.5) to (7.5,0.5);  \(H) at (4,-0.25); (I) at (5.5,-0.25); (J) at (7,-0.25); at (7.8,-0.25)[]{}; at (3.2,-0.25) ; (H1) at (4,-0.75); (I1) at (5.5,-0.75); (J1) at (7,-0.75); at (4, -1.25); at (5.5, -1.25); at (7, -1.25); at (5.5,0);  \(H) to (I); (I) to (J); (H1) to (H); (I1) to (I); (J1) to (J); (J) to (7.5,-0.25); (3.2,-0.25) to (H);  (3.5,-1.5) to (H1); (4.5,-1.5) to (H1); (3.5,-1.5) to (4.5,-1.5);  (5,-1.5) to (I1); (6,-1.5) to (I1); (5,-1.5) to (6,-1.5);  (6.5,-1.5) to (J1); (7.5,-1.5) to (J1); (6.5,-1.5) to (7.5,-1.5);  at (3.5, -2.08);  Cenzer, Harizanov, and Remmel investigated computably categorical (2,0):1 structures by considering additional structural and algorithmic properties. They also characterized the computably categorical 2:1 structures by proving the following theorem.\  A computable 2:1 structure is computably categorical if and only if has only finitely many -chains.  In this paper, we define a (2,1):1 structure, which is a natural extension of the structures introduced by Cenzer, Harizanov, and Remmel. Our ultimate goal is to provide a characterization of computable categoricity for these directed graphs, as has been done for the graphs discussed above. In Section 2, we establish fundamental structural and computability-theoretic properties of (2,1):1 structures, and use these to investigate computable categoricity for such structures. In section 3, we present some examples of (2,1):1 structures with certain desired computability-theoretic properties.">
</outline>
<outline text="Computable Categoricity of (2,1):1 Structures" _note="We begin this section by defining a (2,1):1 structure.  A (2,1):1 STRUCTURE is a set together with a function such that for all . That is, every element in has either exactly two pre-images or exactly one pre-image under .  Naturally, we say that a (2,1):1 structure is COMPUTABLE if is a computable set and is a computable function. From now on, we will assume that all of our (2,1):1 structures are computable, with , unless otherwise stated.  Although we have mentioned the concept in the introduction, we must now formally define the ORBIT OF AN ELEMENT in a (2,1):1 structure.  Let be a (2,1):1 structure, and let .The ORBIT OF IN , denoted by , is defined as follows:\  Here, denotes the result of iterating the function M times on . If we think of (2,1):1 structures as directed graphs, we can think of orbits as the connected components of the graph.  It is not hard to see that a (2,1):1 structure can only consist of two general types of orbits. We refer to them as **K-cycles** and **-chains**, following the naming conventions for the orbits of 2:1 structures used by Cenzer, Harizanov, and Remmel. We describe these orbits below.\ [**K-Cycles**]{}  A **K-cycle** is a directed cycle with elements, where every element in the cycle has a directed binary tree attached, each of which is either infinite or empty.  \(A) at (0,1)  ; (B) at (1,0)   ; (C) at (0,-1)  ; (D) at (-1,0)  ;  (A1) at (0,1.5); (A2) at (0,2); (A3) at (0,2.5); (A4) at (0,3); (A5) at (0,3.5)[]{};  (B1) at (1.5,0); (B21) at (2,-1); (B22) at (2, 1); (B31) at (2.5,-1.5); (B32) at (2.5, -0.5); (B33) at (2.5, 0.5); (B34) at (2.5, 1.5); (B41) at (3.5, -1.75); (B42) at (3.5, -1.25); (B43) at (3.5, -0.75); (B44) at (3.5, -0.25); (B45) at (3.5, 0.25); (B46) at (3.5, 0.75); (B47) at (3.5, 1.25); (B48) at (3.5, 1.75); (B5) at (4,0)[]{};  (D1) at (-1.5,0); (D21) at (-2, 1); (D22) at (-2, -1); (D31) at (-2.5, 1); (D32) at (-2.5, -0.5); (D33) at (-2.5, -1.5); (D41) at (-3.5, 1.25); (D42) at (-3.5, 0.75); (D43) at (-3.5, -0.5); (D44) at (-3.5, -1.25); (D45) at (-3.5, -1.75); (D5) at (-4,0)[]{};  \(A) to   (B); (B) to   (C); (C) to   (D); (D) to   (A);  (A1) to (A); (A2) to (A1); (A3) to (A2); (A4) to (A3);  (B1) to (B); (B21) to (B1); (B22) to (B1); (B31) to (B21); (B32) to (B21); (B33) to (B22); (B34) to (B22); (B41) to (B31); (B42) to (B31); (B43) to (B32); (B44) to (B32); (B45) to (B33); (B46) to (B33); (B47) to (B34); (B48) to (B34);  (D1) to (D); (D21) to (D1); (D22) to (D1); (D31) to (D21); (D32) to (D22); (D33) to (D22); (D41) to (D31); (D42) to (D31); (D43) to (D32); (D44) to (D33); (D45) to (D33);  An element of a K-cycle is called a **cyclic element** if there exists an such that . We denote the cyclic elements of a K-cycle by , ,...,, where for , and for , and . Since each K-cycle consists of only one directed cycle, we can uniquely specify a particular K-cycle within a (2,1):1 structure by listing its K cyclic elements.  In Figure 4, each of the cyclic elements , , , has a different type of binary tree attached. The tree attached to is often referred to as a **degenerate tree**, where every element in the tree has exactly one pre-image. The tree attached to is a **full binary tree**, as every element has exactly two pre-images. The tree attached to is the **empty tree**, and the tree attached to is an arbitrary infinite binary tree that is neither empty, degenerate, nor full.\ [**-Chains**]{}  A **-chain** consists of a -orbit of elements, where every element in the orbit has a directed binary tree attached, each of which is either infinite or empty.  \(A) at (1,0) ; (B) at (2,0) ; (C) at (4,0) ; (D) at (6,0) ; (E) at (8,0) ; (F) at (10,0) ; (G) at (11,0) ; (X) at (0.5,0)[]{}; (Y) at (11.5,0)[]{};  (B1) at (2,-1); (B2) at (2,-2); (B3) at (2,-3); (B4) at (2,-4); (B5) at (2,-4.5)[]{};  (D1) at (6,-1); (D21) at (5, -2); (D22) at (7, -2); (D31) at (4.5, -3); (D32) at (5.5, -3); (D33) at (6.5, -3); (D34) at (7.5, -3); (D41) at (4.25,-4); (D42) at (4.75,-4); (D43) at (5.25,-4); (D44) at (5.75,-4); (D45) at (6.25,-4); (D46) at (6.75,-4); (D47) at (7.25,-4); (D48) at (7.75,-4); (D5) at (6, -4.5)[]{};  (F1) at (10,-1); (F21) at (9,-2); (F22) at (11,-2); (F31) at (8.5, -3); (F32) at (9.5,-3); (F33) at (11,-3); (F41) at (8.5,-4); (F42) at (9.25,-4); (F43) at (9.75,-4); (F44) at (11,-4); (F5) at (10,-4.5)[]{};  \(A) to (B); (B) to (C); (C) to (D); (D) to (E); (E) to (F); (F) to (G);  (B1) to (B); (B2) to (B1); (B3) to (B2); (B4) to (B3);  (D1) to (D); (D21) to (D1); (D22) to (D1); (D31) to (D21); (D32) to (D21); (D33) to (D22); (D34) to (D22); (D41) to (D31); (D42) to (D31); (D43) to (D32); (D44) to (D32); (D45) to (D33); (D46) to (D33); (D47) to (D34); (D48) to (D34);  (F1) to (F); (F21) to (F1); (F22) to (F1); (F31) to (F21); (F32) to (F21); (F33) to (F22); (F41) to (F31); (F42) to (F32); (F43) to (F32); (F44) to (F33);  Here, a -orbit refers to an infinite set of elements such that for all with , . Unlike with cyclic elements in a K-cycle, a -orbit within a -chain does not necessarily UNIQUELY determine the -chain, since a -chain may contain more than one different -orbit. Indeed, if a -chain contains any element with two pre-images, then that -chain will contain more than one distinct -orbit. However, given a -chain, we can establish a **canonical -orbit** , where is the least element in the -chain (under the usual ordering on ), and is the least pre-image of for all . Thus, in Figure 5, if we take the labeled elements to be the canonical -orbit of the -chain, then is the least pre-image of , is the least pre-image of , and so on.  As we can see from Figures 4 and 5, the orbits of a (2,1):1 structure are essentially directed graphs. However, this is not quite correct, as the orbit of an element is only defined to be the SET of elements in the same connected component as , and does not include any additional structure specifying an edge relation. It is advantageous to be able to refer to a connected component in a (2,1):1 structure as a directed graph instead of just a set of vertices. So we formalize this notion in the following definition.  Let be a (2,1):1 structure, and let . The CONNECTED COMPONENT OF IN , denoted by , is the directed graph associated with . That is:  where and .  To further analyze our structures as graphs, we explore another fundamental property: the TREE OF AN ELEMENT.  Let be a (2,1):1 structure, and let . The TREE OF IN , denoted by , is defined as:  Furthermore, the TREE OF IN , denoted by , is the directed graph associated with . That is:  where and .  Intuitively, we can think of as the set of all PREDECESSORS of (or the set of all elements that will eventually LEAD to ), and we can think of as a rooted binary tree with as its root. It is apparent that if is a cyclic element, then , which is the entire K-cycle containing . However, we often wish to refer to those elements in a K-cycle that are connected to a cyclic element via a directed path that does not contain other cyclic elements. So we introduce the notion of an EXCLUSIVE TREE.  Let be a (2,1):1 structure, and let be a cyclic element on a K-cycle in . The EXCLUSIVE TREE OF IN , denoted by , is the following set:  The EXCLUSIVE TREE OF IN , denoted by is the directed graph associated with .  The following properties of (2,1):1 structures will also be useful later.\  Let be a (2,1):1 structure, , and .  The NTH LEVEL OF THE TREE OF , denoted by , is defined as:  Similarly, the NTH LEVEL OF THE EXCLUSIVE TREE OF is defined as:  The TREE OF TRUNCATED AT LEVEL N, denoted by , is defined as:  Similarly, the EXCLUSIVE TREE OF TRUNCATED AT LEVEL N is defined as:  Naturally, and are the associated directed graphs for the sets described in Definition 2.6(b).  Finally, we introduce two special functions for (2,1):1 structures, the BRANCHING FUNCTION and the BRANCH ISOMORPHISM FUNCTION, which will allow us to further study the computable categoricity of our graphs.  Let be a (2,1):1 structure. The BRANCHING FUNCTION OF , denoted by , is defined as:   The HAIR SET OF , denoted by , is defined as:  []{}  The SPLIT HAIR SET OF , denoted by , is defined as:  Let be a (2,1):1 structure, and let have distinct pre-images and . The BRANCH ISOMORPHISM FUNCTION OF , denoted by , is defined as:  Essentially, the branching function takes an element as an input, and outputs the number of immediate predecessors of . The branch isomorphism function takes an element with two distinct pre-images as an input, and tells us if the TREES of those pre-images are isomorphic to each other. Note that if is a cyclic element, then . This is because one predecessor of will be another cyclic element while the other predecessor will be a non-cyclic element , so will be the entire K-cycle containing , while will be an infinite binary tree with no cycles. Hence, is clearly not isomorphic to .  It is also important to note that neither nor is necessarily a computable function, even if the underlying (2,1):1 structure is computable. (In Section 3, we will construct an example of such a structure.) Also, while the domain of is always computable, the domain of may not be computable. In fact, if is not computable, then neither is the domain of . We generally avoid this issue by assuming that the branching function is computable. However, computability of the branching function does not guarantee computability of the branch isomorphism function, as we will see in Section 3.  We will now establish our first result regarding computable isomorphisms between (2,1):1 structures.  Let and be two computable isomorphic (2,1):1 structures, both with a computable branching function and a computable branch isomorphism function. If and are non-cyclic elements such that , then the two Trees are computably isomorphic. Likewise, if and are cyclic elements such that , then the two exclusive Trees are computably isomorphic.  We construct a computable isomorphism from to in stages as follows.\ STAGE 0: Define .  STAGE S+1: Suppose that from stage we have , an isomorphism from to . For all elements , define . Let and let . If , find the unique pre-image of under , call it , and find the pre-image of under , call it . Then define .  If , find both pre-images of under , call them and , and then find both pre-images of under , call them and . If , then define and , where and are defined under the usual ordering on . If , then there exists a level such that . In that case, use to reveal the vertices and edges of and one level at a time until we find such a level . Then, use to reveal the vertices and edges of and . If , then define and . Otherwise, define and .  Repeat the procedure above for all , so is defined on all elements in . This completes the construction. Let .  We must now verify that is a computable isomorphism from to .\ **Claim 1**. The function is an isomorphism from to .\ PROOF OF CLAIM 1. Suppose is an isomorphism from to such that there exists an isomorphism from to with . Let and let .  If , then it must be the case that as well. This means that and each have a unique pre-image, and respectively, and so we can properly extend to by defining . Furthermore, any isomorphism from to that extends must map to . Thus, there certainly exists an isomorphism from to that extends and agrees with on .  If , then again, it must be the case that . So let and be the distinct pre-images of under , and let and be the distinct pre-images of under . If , then it must be the case that . Moreover, the TREES of both and are isomorphic to the TREES of both and . So regardless of where maps and , there will exist an isomorphism from to that extends and agrees with on both and . If , then it must be the case that as well. It follows from the construction that if maps to , then , and thus it must be that . The reverse statement also holds if maps to . Since the branches of (and the branches of ) are not isomorphic to each other, any isomorphism from to extending must agree with on and .  Thus, it is apparent that , once defined on all elements in , is an isomorphism from to . Furthermore, there must exist an isomorphism from to that extends , as the branching functions and the branch isomorphism functions prevent us from “making a mistake&quot; throughout the construction. Hence, is a proper extension of for all stages , and once is defined at a stage , it is never redefined again. Therefore, exists and is an isomorphism from to .\ **Claim 2**. The isomorphism is a computable function.\ PROOF OF CLAIM 2. Let . To determine we run through the stages of the construction until is defined on . By the assumption that the branching function and branch isomorphism function for both structures are computable, we can easily see that the construction is computable at every stage. Therefore, we can effectively determine the image of under .\ The construction of a computable isomorphism from to is almost identical to the one presented above. The only difference is that at stage , after mapping to at stage , we must then determine via the branching functions whether and have non-cyclic pre-images. If they don’t, then and are trivially computably isomorphic. Otherwise, we find the non-cyclic pre-images of both and (which, of course, can be done computably), then define as a map from the non-cyclic pre-image of to that of .  It is worth noting that the construction in Lemma 2.9 can be done without the explicit assumption that and are computable.\ We conclude this section with our main theorem, which gives a general sufficient condition for a (2,1):1 structure to be computably categorical.  Let be a computable (2,1):1 structure without -chains and with and computable. If for each , has only finitely many k-cycles, then is computably categorical.  Suppose that is a (2,1):1 structure as described above, and is a computable structure isomorphic to . For each , has only finitely many k-cycles, and thus has only finitely many cyclic elements in those k-cycles, which we can computably identify. So we can non-uniformly and isomorphically map each of these cyclic elements in to a corresponding cyclic element in via a computable function. Then, by Lemma 2.9, we can construct a computable isomorphism from to for . Let . Then is a computable isomorphism from the k-cycles in to those in .  Repeat the procedure above for each , and let . Since has no -chains, every element in is in some k-cycle of . So, is a computable isomorphism from to . Thus, is computably categorical.">
</outline>
<outline text="Examples" _note="In this section, we present some examples of (2,1):1 structures with various computability-theoretic properties. Our first example illustrates our point from Section 2 that computability of a (2,1):1 structure does not guarantee computability of its branching function (nor its branch isomorphism function).  There exists a computable (2,1):1 structure such that is not computable.  Our goal is to construct a computable (2,1):1 structure such that is not a computable set. So let be some computably enumerable set that contains and is not computable. Then has a partial computable characteristic function such that if , and if (i.e., computes forever, that is, never halts on input ). In stages, we build to be a single 1-cycle.\ STAGE 0: Let , and let .  STAGE 1: Let , and let and .  STAGE S+1: Suppose we have and from stage . Find the least such that  , and   (i.e., halts and equals 1 on input in at most steps of its computation).  If no such exists, simply extend to and to by attaching one new number (not already in ) to each number in . Then move on to the next stage.  If such an does exist, take the least number not already in and define . Denote the level of in by , and extend the TREE of by attaching new numbers to such that for . Then extend to by attaching one new number to each number in . Define and continue extending to accordingly. Then move on to the next stage.  Finally, let and . This completes the construction of . We must now verify two claims.\ **Claim 1**: is a computable (2,1):1 structure.\ PROOF OF CLAIM 1: We have that , and is thus clearly computable. To compute , we simply run through the construction until we reach the stage where appears, and then determine . Due to the construction, once is defined on an element, we never redefine it at a later stage. Thus, , and is computable. Therefore, is computable.  To see that is a (2,1):1 structure, first observe that has exactly two pre-images, and . Also note that at every stage, we extend the exclusive tree of by one level, so every element has at least one pre-image. The only instance where an element is given an additional pre-image is if it had exactly one pre-image, so no element has more than two pre-images. Thus, every element either has exactly one or exactly two pre-images, making a (2,1):1 structure.\ **Claim 2**: The branching function is not computable.\ PROOF OF CLAIM 2: Observe that if and only if has two pre-images, which is if and only if . Thus, is computable if and only if is computable. However, is not a computable set by assumption. Therefore, cannot be computable.  The following example demonstrates that computability of the branching function does not imply computability of the branch isomorphism function.  There exists a computable (2,1):1 structure such that is computable but is not computable.  We wish to construct a computable (2,1):1 structure such that is computable, but no computable function computes the branch isomorphism function . We will accomplish this by building using a standard priority argument to ensure that for all , the following requirement is satisfied:  We start with an effective enumeration of all partial computable functions . Our desired structure will again be a single 1-cycle, which we will construct in stages as follows.\ STAGE 0: Define , and .  STAGE S+1: Suppose we have and from the previous stage. Let denote the lowest level of the exclusive tree of 0 at the end of stage , i.e., is the unique number such that , and for all , .  First, assign to level , where is the least number such that has not been assigned to a level of the exclusive tree at a previous stage. Let denote the level of that has been assigned to, so . (We will only assign a partial computable function to a level of the exclusive tree that contains only elements with two pre-images.) Then, find the least such that:   for some , and   has not yet received attention.  If no such exists, extend to , and to , by attaching two unused even numbers as pre-images to every number in . Set and go on to the next stage.  If such an exists, we say that REQUIRES ATTENTION. If , let and be the distinct pre-images of , with . Attach two unused odd numbers to every element that is in both and , and attach two unused even numbers to every element that is in both and . If , then simply attach one unused odd number and one unused even number to . In either case, repeat the procedure for every number in the same level of the exclusive tree of as . Now, the level of the exclusive tree of is complete.  Then, to every odd number in , attach exactly one unused even number. To every even number in , attach exactly two unused even numbers. This completes the level of the exclusive tree of . Let\  extend to as described above, and set . At this point, has RECEIVED ATTENTION and we move on to the next stage.  This ends the construction. Let and . We must now prove the following two claims.\ **Claim 1**: The structure is a computable (2,1):1 structure with computable.\ PROOF OF CLAIM 1: By construction, . To compute , we simply run through the construction until we reach the stage where appears, then determine . Due to the construction, once is defined on an element, we never redefine it at a later stage. Thus, , and is computable.  To see that is a (2,1):1 structure, observe that every even number has exactly two pre-images, and every odd number has exactly one pre-image. This also proves that is a computable function.\ **Claim 2**: The branch isomorphism function is not computable.\ PROOF OF CLAIM 2: We prove by induction that each requirement is satisfied. At stage , is assigned to level of the exclusive tree of , so is assigned to the single number . If for some stage , then would require attention at stage . However, due to the construction, the isomorphism on the branches of 2 would be ruined at stage , and thus for all stages , and . Hence, is satisfied. Otherwise, for any stage and thus . But the only requirement that can ruin the isomorphism on the branches of is . (Any requirement receiving attention only ruins the isomorphism on the branches of the elements in its assigned level, due to the symmetry of the construction.) Thus, for all stages , , which means that . Again, is satisfied.  Now suppose that for all , is satisfied. At stage , is assigned to some level . If there do not exist a stage and a number in level such that , then is satisfied since for all by the same argument as before. Otherwise, let be the first stage at which for all , does not require attention and for some in level . Then at stage , would require attention, and the construction would ensure that for all stages . So, and again, would be satisfied. Therefore, all requirements are satisfied and is not computable.  The next example illustrates what can go wrong if we relax one of the conditions in Theorem 2.10, and allow a (2,1):1 structure to have infinitely many K-cycles of one size.  There exists a computable (2,1):1 structure with no -chains such that and are computable, but is not computably categorical.  We shall first present a computable (2,1):1 structure with the desired properties, and then construct a computable isomorphic structure that is not computably isomorphic to .  Let be the (2,1):1 structure where and is defined as follows:  \(A) at (1,0) ; (B) at (2,0) ; (C) at (3,0) ; (D) at (4,0) ; (E) at (5,0) ; (F) at (6,0) ; (G) at (7,0) ; (H) at (8,0) ; at (9,0) []{};  (B1) at (2,-1) ; (B2) at (2,-2) ; (B3) at (2,-3) ; (B4) at (2,-3.5)[]{};  (D1) at (4,-1) ; (D2) at (4, -2) ; (D3) at (4, -3) ; (D4) at (4, -3.5)[]{};  (F1) at (6,-1) ; (F2) at (6,-2) ; (F3) at (6,-3) ; (F4) at (6,-3.5)[]{};  (H1) at (8,-1) ; (H2) at (8,-2) ; (H3) at (8,-3) ; (H4) at (8,-3.5)[]{};  \(A) to  (1.3,0.3); (1.3,0.3) to  (1,0.6); (1,0.6) to  (0.7,0.3); (0.7,0.3) to  (A);  \(B) to  (2.3,0.3); (2.3,0.3) to  (2,0.6); (2,0.6) to  (1.7,0.3); (1.7,0.3) to  (B);  \(C) to  (3.3,0.3); (3.3,0.3) to  (3,0.6); (3,0.6) to  (2.7,0.3); (2.7,0.3) to  (C);  \(D) to  (4.3,0.3); (4.3,0.3) to  (4,0.6); (4,0.6) to  (3.7,0.3); (3.7,0.3) to  (D);  \(E) to  (5.3,0.3); (5.3,0.3) to  (5,0.6); (5,0.6) to  (4.7,0.3); (4.7,0.3) to  (E);  \(F) to  (6.3,0.3); (6.3,0.3) to  (6,0.6); (6,0.6) to  (5.7,0.3); (5.7,0.3) to  (F);  \(G) to  (7.3,0.3); (7.3,0.3) to  (7,0.6); (7,0.6) to  (6.7,0.3); (6.7,0.3) to  (G);  \(H) to  (8.3,0.3); (8.3,0.3) to  (8,0.6); (8,0.6) to  (7.7,0.3); (7.7,0.3) to  (H);  (B1) to (B); (B2) to (B1); (B3) to (B2);  (D1) to (D); (D2) to (D1); (D3) to (D2);  (F1) to (F); (F2) to (F1); (F3) to (F2);  (H1) to (H); (H2) to (H1); (H3) to (H2);  This structure is easily seen to be a computable (2,1):1 structure. We can also see that if (mod 4), and otherwise. So the function is clearly computable as well. The branch isomorphism function is trivially computable, since for all . Finally, is composed entirely of 1-cycles, and thus contains no -chains. Thus, has all of the desired properties.  Let denote the halting set. We build an isomorphic copy in stages as follows.\ STAGE 0: Let and let .  STAGE S+1: Suppose we are given and from stage . Find the least such that:\  , and  If no such exists, extend to and to by defining . This adds a 1-cycle to . Also, extend any existing degenerate trees that are attached to a 1-cycle by adding an unused odd number to the end of each one. Go on to the next stage.  If such an exists, extend to and to in the following manner. Attach a degenerate tree of height , composed entirely of unused odd numbers, to the 1-cycle containing . Then, extend all existing degenerate trees attached to a 1-cycle by adding an unused odd number to the end of each one. Add a new 1-cycle by defining . Then go on to the next stage.  At the end of the construction, let , and . It is easy to see that is a computable (2,1):1 structure. Also, observe that if and only if . Since is not computable, both and are infinite, which means that has infinitely many 1-cycles with degenerate trees attached and infinitely many 1-cycles with empty trees attached, as does . Thus, .  However, cannot be computably isomorphic to . This is because is computable but is not, as the computability of would imply the computability of . A computable isomorphism from to would preserve the computability of the split hair set, so no such computable isomorphism can exist. Therefore, is not computably categorical.  Note that the conditions in Theorem 2.10 are sufficient for computable categoricity, but not necessary. By Theorem 1.3, it is possible for a (2,1):1 structure to have infinitely many K-cycles of the same size and still be computably categorical.  [12]{}  W. Calvert, D. Cenzer, V. Harizanov, and A. Morozov. Effective categoricity of equivalence structures. ANNALS OF PURE AND APPLIED LOGIC 141 (2006), pp. 61–78.  D. Cenzer, V. Harizanov, and J.B. Remmel. Computability-theoretic properties of injection structures. ALGEBRA AND LOGIC 53 (2014), pp. 39–69  D. Cenzer, V. Harizanov, and J.B. Remmel. Two-to-one structures. JOURNAL OF LOGIC AND COMPUTATION 23 (2013), pp. 1195–1223  B. Csima, B. Khoussainov, and J. Liu. Computable categoricity of graphs with finite components. LECTURE NOTES IN COMPUTER SCIENCE 5028 (2008), pp. 139–148.  V.D. Dzgoev and S.S. Goncharov. Autostability of models. ALGEBRA AND LOGIC 19 (1980), pp. 28–37.  S. Goncharov, S. Lempp, and R. Solomon. The computable dimension of ordered abelian groups. ADVANCES IN MATHEMATICS 175 (2003), pp. 102–143  P. LaRoche. Recursively presented boolean algebras. NOTICES OF THE AMERICAN MATHEMATICAL SOCIETY 24 (1977), A552–A553.  S. Lempp, C. McCoy, R. Miller, and R. Solomon. Computable categoricity of trees of finite height. JOURNAL OF SYMBOLIC LOGIC 70 (2005), pp. 151–215.  R. Miller. The computable dimension of trees of infinite height. JOURNAL OF SYMBOLIC LOGIC 70 (2005), pp. 111–141  J.B. Remmel. Recursive isomorphism types of recursive boolean algebras. JOURNAL OF SYMBOLIC LOGIC 46 (1981), pp. 572–594.  J.B. Remmel. Recursively categorical linear orderings. PROCEEDINGS OF THE AMERICAN MATHEMATICAL SOCIETY 83 (1981), pp. 387–391  R.I. Soare. RECURSIVELY ENUMERABLE SETS AND DEGREES. A STUDY OF COMPUTABLE FUNCTIONS AND COMPUTABLY GENERATED SETS. Spring-Verlag, Berlin, 1987.">
</outline>
  </body>
</opml>