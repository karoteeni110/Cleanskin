<?xml version="1.0" encoding="UTF-8"?>
<opml version="2.0">
  <head>
    <title>Scalable Multi-Database Privacy-Preserving Record Linkage using Counting
Bloom Filters</title>
    <abstract>Privacy-preserving record linkage (PPRL) aims at integrating sensitive
information from multiple disparate databases of different
organizations. PPRL approaches are increasingly required in real-world
application areas such as healthcare, national security, and business.
Previous approaches have mostly focused on linking only two databases as
well as the use of a dedicated linkage unit. Scaling PPRL to more
databases (multi-party PPRL) is an open challenge since privacy threats
as well as the computation and communication costs for record linkage
increase significantly with the number of databases. We thus propose the
use of a new encoding method of sensitive data based on COUNTING BLOOM
FILTERS (CBF) to improve privacy for multi-party PPRL. We also
investigate optimizations to reduce communication and computation costs
for CBF-based multi-party PPRL with and without the use of a dedicated
linkage unit. Empirical evaluations conducted with real datasets show
the viability of the proposed approaches and demonstrate their
scalability, linkage quality, and privacy protection. </abstract>
  </head>
  <body>
<outline text="Introduction" _note="A wide range of real-world applications, including in healthcare, government services, crime and fraud detection, national security, and businesses, require person-related data from multiple sources held by different organizations to be integrated or linked. Integrated data can then be used for data mining and analytics to empower efficient and quality decision making with rich data. Integrating data helps improving the quality of data by identifying and resolving conflicts in data values, enriching data with additional detailed information, and dealing with missing values .  The analysis and mining of data integrated across organizations can be used, for example, in health outbreak systems that allow the early detection of infectious diseases before they spread widely around a country or even worldwide. Such an application requires data to be integrated across several sources, including human health data, travel data, consumed drug data, and even animal health data . A second contemporary motivating example is national security applications that integrate data from law enforcement agencies, Internet service providers, businesses, as well as financial institutions to enable the accurate identification of crime and fraud, or of terrorism suspects .  In the absence of unique entity identifiers in the databases that are to be linked, personal identifying attributes (such as names and addresses) need to be used for the linkage. Known as quasi-identifiers (QIDs) , such attribute values are in general assumed to be sufficiently well correlated with entities to allow accurate linkage. Using such personal information across different organizations, however, often leads to privacy and confidentiality concerns. This problem has been addressed through the development of ‘privacy-preserving record linkage’ (PPRL)  techniques. PPRL aims to conduct linkage using only masked (encoded) QIDs without requiring any sensitive or confidential information to be exchanged and revealed between the organizations involved in the linkage. Generally, masking is conducted on QIDs to transform the original values such that a specific functional relationship exists between the original and the masked values . While there have been many different approaches proposed for PPRL (as reviewed in ), most work thus far has concentrated on linking records from only two sources (or parties). As the healthcare and national security examples described above show, linking data from several sources is however commonly required in practical applications.   []{}  The drawback of the small number of existing PPRL solutions that can link data from multiple parties is that either (1) they only support exact matching (which classifies sets of records as matches if their masked QIDs are exactly the same and as non-matches otherwise) or (2) they are applicable to QIDs of categorical data only . However, in many PPRL applications QIDs of string data, such as names and addresses, are required. These QIDs often contain errors and variations which necessitates the use of approximate comparison functions (that are computationally expensive in terms of the number of comparisons) for comparing QIDs. In this paper, we tackle the multi-party PPRL problem by developing an efficient privacy-preserving approach for approximate matching of (masked) QIDs of string data from multiple records.  We propose the use of Counting Bloom Filter (CBF) encoding, which is a variation of Bloom filter (BF) encoding , to enable efficient and approximate privacy-preserving linkage of multiple databases. BFs are bit vectors into which values are hash-mapped using hash functions (as we describe in Section  ). CBFs, on the other hand, are integer vectors that contain count values in each position. Multiple BFs can be summarized as a single CBF using the vector addition operation between BFs. Previous BF encoding-based PPRL approaches  suggest using a linkage unit (), which is a dedicated external party that can perform linkage by comparing candidate record sets (masked into BFs) from all database owners and calculating their similarities to classify them as matches or non-matches. Our hypothesis is that, rather than sending BFs from all parties to a linkage unit () to calculate their similarity, a single CBF for each candidate record set generated over parties can be used to calculate their similarity, as illustrated in Figure   (left for BFs and right for CBFs). Since CBFs contain only the summary information (count values) of multiple records in their positions rather than the actual individual bit values of a single record as in BFs, they provide increased privacy compared to BFs, as we discuss in Section  . To the best of our knowledge, this privacy aspect of CBFs has so far not been utilized in PPRL.  An additional challenge with multi-party PPRL is that complexity increases significantly with multiple parties in terms of both computational efforts and communication volume. A basic approach would be to send all masked records from all parties to a that can calculate pair-wise similarities between masked records, which is of complexity, where is the size of databases assuming all databases are of equal size. However, identifying a matching set of records from all parties is not possible with such a basic pair-wise comparison approach. On the other hand, the number of naïve (all-to-all) comparisons between records required across all databases (, , , ) is equal to the product of the size of the databases (i.e. ). Addressing this complexity challenge, two-step algorithms have been developed where in the first step a private indexing/blocking technique is used to reduce the number of candidate record sets from to , assuming blocks of equal size. In the second step only these candidate record pairs have to be compared and classified . Compared to the quadratic number of record pairs when linking only two databases (), in multi-party PPRL the number of candidate record sets increases exponentially with the number of parties (), and thus using existing private blocking techniques would not sufficiently reduce the number of comparisons, as has been empirically studied in several recent approaches .  Figure   overviews the naïve computation and communication of (masked) candidate record sets from multiple parties () using a . Independent of the used masking function (BFs in the left figure and CBFs in the right figure) and the communication pattern (direct one-to-one communication between each party and the in the left figure and ring-based communication among the parties in the right figure, as will be described in Section  ), the naïve approach results in exponential complexity. Efficient communication patterns and advanced filtering approaches for multi-party PPRL therefore need to be developed in order to reduce the potentially huge number of comparisons. Moreover, with multiple parties the privacy risk of collusion increases, where a sub-set of parties collude among them in order to learn about another party’s (or sub-set of parties’) private data. Both examples for the naïve method described in Figure   are highly susceptible to collusion.  In order to overcome these scalability and privacy challenges of multi-party PPRL, we introduce two efficient CBF-based communication patterns that either use a or operate symmetrically without a (where a trusted external party is not available to act as a ). The proposed approaches can significantly reduce the number of comparisons required between records in contrast to the naïve all-to-all comparisons, and thereby improve the scalability while also improving the privacy (reducing the likelihood of collusions) by arranging parties into several groups and by distributing computations among parties.  **Contributions:** Our contributions in this paper are: (1) a novel multi-party PPRL protocol based on CBFs and secure summation for efficient, approximate, and private linkage; (2) two variations of extended secure summation protocols for improved privacy against collusion among the data base owners: (a) homomorphic encryption-based and (b) salting-based (using random seed integers); (3) two efficient communication patterns (with and without a ) for reducing the comparison space and risk of collusion between parties and thereby improving scalability and privacy, respectively, in multi-party PPRL; (4) an analysis of the protocol in terms of the three properties of PPRL: scalability (complexity), linkage quality, and privacy; and (5) an empirical evaluation and comparison of our protocol with two baseline approaches using large North Carolina Voter Registration (NCVR)  datasets.  **Outline:** In the following section we describe the preliminaries. In Section   we propose our protocol for multi-party PPRL based on CBFs and secure summation, where in Section   we we propose two extended secure summation protocols to improve privacy of our approach, and in Section   we introduce two efficient communication patterns to improve scalability and privacy. We analyze our protocol in terms of complexity, linkage quality, and privacy in Section  , and in Section   we conduct an empirical study on the NCVR datasets to validate these analyses. We provide a review of related work in Section  . Finally, we summarize and discuss future research directions in Section  .">
</outline>
<outline text="Preliminary concepts and building blocks" _note="In this section, we define the problem of multi-party PPRL and explain how CBFs can be used for efficiently calculating similarities (approximate matching) of QID values between a set of multiple (two or more) records (held by different parties) in PPRL.  We assume database owners , , , with their respective databases , , , (containing sensitive or confidential identifying information) participate in the process under the honest-but-curious (HBC) . In the HBC model, parties are assumed to follow the protocol without deviating or sending false information while being curious to learn about other parties’ data. However, the HBC model does not assume that the parties do not collude among them to learn about other parties’ data . We quantify the risk of collusion in multi-party PPRL and the reduction of risk by our communication patterns in Section  . We also assume a set of QID attributes , which will be used for the linkage, is common to all these databases. We formally define the problem of PPRL of multiple databases as follows.  **Multi-party PPRL**: Assume are the owners (parties) of the databases , respectively. They wish to determine which of their records , , , match based on the (masked) QIDs of these records according to a decision model ,, , that classifies record sets ,, , into one of the two classes of matches and of non-matches. Assuming the HBC adversary model, parties are honest, in that they follow the linkage protocol steps, while they do not wish to reveal their actual records with any other party. They however are prepared to disclose to each other, or to an external party, the actual values of some selected attributes of the record sets that are in class to allow analysis.  Masking functions used for privacy-preserving algorithms can be categorized into two: cryptographic-based secure multi-party computation (SMC) techniques and perturbation-based techniques . The former approach is generally more expensive with regard to the computation and communication complexities though it provides strong privacy guarantees and high accuracy . The latter uses efficient techniques and, as opposed to SMC techniques, these techniques aim to hide (mask) information about the original values (to preserve privacy) while still allowing to perform approximate matching between the masked values using the functional relationship between original and masked data.  We propose an efficient protocol for multi-party PPRL using perturbation-based masking. In this section, we describe the four building blocks of our protocol, and in Section   we present our algorithm in detail. In the following two sections we assume a linkage unit () is available to conduct the linkage, and in Section   we propose a variation where a is not required to conduct the linkage using our protocol.">
  <outline text="Bloom filter encoding" _note="Bloom filter (BF) encoding has been used as an efficient masking (encoding) technique in several PPRL solutions . A BF is a bit array data structure of length bits where all bits are initially set to . independent hash functions, , each with range , are used to map each of the elements in a set into the BF by setting the bit positions with to .  Schnell et al.  were the first to propose a method for approximate matching in PPRL of two databases using BFs. In their work, as in our protocol, the character -grams (sub-strings of length ) of QID values in of each record in the databases to be linked are hash-mapped into a BF using independent hash functions. This method of BF encoding is known as Cryptographic Long term Key (CLK) encoding .  These BFs are then either sent to a that calculates the similarity of pairs of BFs, as suggested by Schnell et al.  and Durham et al. , or they are partially exchanged among the database owners to distributively calculate the similarities of BF pairs/sets, as proposed by Lai et al.  and Vatsalan and Christen for two-party  and multi-party  approaches. Figure  (a) illustrates the encoding of bigrams () of two QID values ‘peter’ and ‘pete’ into bits long BFs using hash functions.   []{}">
  </outline>
  <outline text="Dice coefficient" _note="Any set-based similarity function (such as overlap, Jaccard, and Dice coefficient) can be used to calculate the similarity of pairs or sets of (multiple) BFs. The Dice coefficient has been used for matching of BFs since it is insensitive to many matching zeros (bit positions to which no -grams are hash-mapped) in long BFs . In future, we aim to investigate how other approximate string comparison functions, such as edit distance  and Jaro and Winkler , can be extended to calculate the similarity of more than two values.  We define the Dice coefficient similarity of BFs () as: where is the number of common bit positions that are set to in all BFs (common -bits), and is the number of bit positions set to in (-bits), .  Figure  (a) illustrates the Dice coefficient similarity calculation of the two QID values ‘peter’ and ‘pete’ masked into BFs.">
  </outline>
  <outline text="Secure summation" _note="A secure summation protocol  can be used to securely sum the input values of multiple parties (), such that no party learns the individual values of other parties, but only the summed value. The input can either be a single numeric value or a vector of numeric values. For example, numeric values () can be securely summed by using a random numeric value which is sent by a . The first party that receives calculates the summation of and sends to . This process is repeated until the last party sends to the which then subtracts from the summed value to calculate the summation of values. The protocol employs a ring-based communication pattern over all parties which allows the to learn the final values () but no party will learn the values of the other parties. This basic secure summation (BSS) protocol is susceptible to collusion risk among the parties. In Section   we propose extended secure summation protocols for improved privacy against collusion.">
  </outline>
  <outline text="Counting Bloom filters (CBFs)" _note="In this section we propose a novel method of calculating the similarity of BFs using a CBF, which will provide increased privacy compared to using BFs for similarity calculation, as we will discuss in Section  . A CBF of () BFs is an integer array data structure of the same length as the BFs (). It contains the counts of values in each bit position over a set of BFs in its corresponding position, such that , where is the count value in the bit position of the CBF and provides the value in the bit position of BF . Given BFs (bit vectors) with , the CBF can be generated by applying a vector addition operation between the bit vectors such that .  The Dice coefficient similarity of BFs can be calculated given only a CBF as:  The Dice coefficient similarity of BFs (,, , ) is determined by the sum of -bits () in the denominator of Eq. ( ) and the number of common -bits () in all BFs in the nominator of Eq. ( ). The number of -bits in a BF is , with . The sum of -bits in all BFs is therefore . The value in a bit position () of the CBF of these BFs is . The sum of values in all bit positions of the CBF is which is equal to . Further, if a bit position () contains in all BFs, i.e. , then . Therefore, the common -bits () that occur in all BFs can be calculated by counting the number of positions where , while the sum of number of -bits () is calculated by summing the values in bit positions , .  If the gets only the CBF that contains the summed values in the bit positions of BFs instead of the actual BFs, then the can calculate the Dice coefficient of BFs using Eq. ( ) without learning any information about the individual bit positions of each party. As an example, the Dice coefficient calculation of the two BFs from the two parties and in Figure  (a) is extended by using a CBF and secure summation to calculate the similarity by the , as shown in Figure  (b). The information gained by the (and/or database owners) from a single CBF is less than BFs (i.e. CBFs provide increased privacy compared to BFs), as theoretically proven in Section   and empirically validated in Section  .">
  </outline>
</outline>
<outline text="Multi-party PPRL algorithm" _note="Our protocol allows efficient, approximate, and private linking of records based on their masked QID values in multiple databases from sources/parties. We first describe a basic naïve protocol based on CBFs, which we name as ‘NAI’, and in Section   we then propose improved communication patterns for this protocol to make it more scalable. The steps of our protocol are listed below.  **Step 1:**  The parties agree upon the following parameter values: the BF length ; the hashing functions to be used; the length (in characters) of grams ; a minimum similarity threshold value (), above which a set of records is classified as a match; a private blocking function ; the blocking keys  used for blocking; and a set of QID attributes used for the linkage.  **Step 2:**  Each party () individually applies a private blocking function  to reduce the number of candidate sets of records (from , where is the number of records in held by party ), which otherwise becomes prohibitive even for moderate and . The function groups records according to their blocking key values (BKVs)  and only records with the same BKV (i.e. records in the same block) from different parties are then compared and classified using our protocol. A phonetic-based blocking  or any of the existing multi-party blocking techniques for PPRL  can be used as the function.  [0.46]{}[c @ lll]{}    \ \ \  \ \ [- :]{} &amp;\ [- :]{} &amp;\   &amp;\ \ [- :]{} &amp;\ 1:&amp; &amp;//initialize \ 2:&amp;**for** **do**: &amp;  \ 3:&amp;   **if** **then**:&amp;//first party\ 4:&amp;      **for** **do**: &amp;  \ 5:&amp;         &amp;//summation\ 6:&amp;         &amp;  \ 7:&amp;      &amp;//send to \ 8:&amp;   **else**: &amp;//other parties\ 9:&amp;      &amp;//receive from \ 10:&amp;      **for** **do**: &amp;  \ 11:&amp;         **for** **do**: &amp;  \ 12:&amp;            + &amp;//addition\ 13:&amp;            &amp;\ 13:&amp;            &amp;  \ 14:&amp;      **if** **then**: &amp;  \ 15:&amp;         &amp;//send to \ 16:&amp;      **else**: &amp;  \ 17:&amp;         &amp;//send to /\  \    **Step 3:**  Each party hash-maps the -gram values of QIDs of each of its records in their respective databases into BFs (one BF per record in ) of length using the hash functions . It is crucial to set the BF related parameters in an optimal way that balances all three properties of PPRL (complexity, quality, and privacy). We further discuss parameter setting for BFs used in our protocol in Section  .  **Step 4:**  In the next step, the parties initiate a secure summation protocol to securely perform vector addition between their BFs in order to generate a CBF for each set of candidate records . This secure summation can be initiated by an external linkage unit that provides a vector (of length ) of random values or by one of the parties (as will be discussed further in Section  ). This process is outlined in Algorithm 1.  In lines 3-6, the or the party that initiated the communication (we assume ) sends or uses, respectively, a random vector for each record to sum with the party’s BF vector () by applying a vector addition operation. The summed vectors are then sent to party in line 7. Party , receives the summed vectors from (line 9) and adds its BF vector to each candidate set and sends the summed vectors to the next party . This process is repeated until the last party (i.e. ) adds its vector to each received summed vector from party and sends the final summed vector back to the or for each candidate set , as shown in lines 8-17 in Algorithm 1.  [0.45]{}[c @ lll]{}    \ \ \  \ \ [- :]{} &amp;\   &amp;\ [- :]{} &amp;\   &amp;\ [- :]{} &amp;\ \ [- :]{} &amp;\ 1:&amp;&amp;//initialize \ 2:&amp;&amp;//receive CBFs\ 3:&amp;**for** **do**: &amp;  \ 4:&amp;   &amp;//subtract\ 5:&amp;   &amp;//Eq. ( )\ 6:&amp;   **if** **then**:&amp;//a match\ 7:&amp;      &amp;  \ 8.&amp;**for** **do**: &amp;  \ 9:&amp;   &amp; \  \    **Step 5:**  Finally, either the or the first party, , that has provided the random vectors , subtracts from the final summed vector as received from the last party for each candidate set . This is achieved by subtraction of vectors (i.e. ), which is a special case of vector addition, as outlined in lines 2-4 in Algorithm 2. As shown in lines 5-7, the or then calculates the Dice coefficient similarity of each resulting CBF following Eq. ( ) to classify the compared sets of records (BFs) within a block into matches and non-matches based on the similarity threshold . The final similarities of matching sets of records will be sent to all parties , with , in lines 8-9 in Algorithm 2.  The basic secure summation protocol (BSS) used in this ’NAI’ protocol is vulnerable to collusion risk among the parties. Further, the number of candidate sets to be compared for multi-party linkage in this naïve method (NAI) is exponential in the number of parties and their dataset sizes, which is prohibitively large to be practically feasible (even with the existing private blocking and filtering approaches employed) . Efficient communication patterns among the parties therefore need to be employed in order to make multi-party PPRL scalable and viable in real applications that require data of very large sizes from many parties to be integrated. In the following sections we propose extended secure summation protocols and two efficient communication patterns that not only improve the scalability of our multi-party PPRL protocol but also make it more secure (with less possible collusion among the parties).   []{}">
</outline>
<outline text="Extended secure summation" _note="The basic secure summation protocol (BSS) described in Section   is susceptible to collusion risk by the parties involved, where if two or more parties collude they are able to infer the input of another party. In order to overcome this risk (to improve privacy), we propose two extended secure summation protocols.  Homomorphic-based secure summation (HSS): The partially homomorphic Paillier cryptosystem  is a reliable secure multi-party computation (SMC) technique for performing secure joint computation among several parties. In the HSS approach a pair of private and public keys is used for encrypting and decrypting the individual BF values. Successive encryption of the same value using the same public key generates different encrypted values with high probability, and decrypting the encrypted values using a private key returns the correct original value. The public key is known to all parties while the private key is known only to the . Each party receives summed vectors containing encrypted values to which adds its encrypted vector (using the public key) and sends the encrypted summed vectors to the next party. Without knowing the private key a party cannot decrypt the received vectors and therefore colluding with a party to learn another party’s (with ) would be impossible.  Salting-based (using random seed integers) secure summation (SSS): The HSS approach provides a secure solution compared to the BSS approach against collusion attacks at the cost of an excessive computation overhead, making it not scalable to linking multiple large databases. Therefore, we propose the SSS approach to provide security against collusion attacks in an efficient way. Salting has been used to defend against dictionary attacks on one-way hash functions where an additional string is concatenated with a value to be encrypted . We adopt a similar concept in the SSS approach where the salting key is an additional random integer used by each party individually when performing the secure summation. The salting key generated and used by each party is sent only to the and therefore a party ’s BF values cannot be identified by means of collusion among the parties, as without knowing the salting key of its BF values cannot be learned. Since the salting keys are random integer values, performing secure summation of BFs with the salting keys does not add any additional computation and communication overhead, except the communication of salting keys from parties to the .">
</outline>
<outline text="Communication patterns" _note="In this section, we propose two variations of improved communication patterns for our protocol based on CBFs for multi-party scenarios with and without a linkage unit (). The main idea of these improved communication patterns is to exploit the facts that most candidate sets are true non-matches (due to the class imbalance problem of record linkage ), and that a true matching set must have a high similarity between any sub-set of records in that set. Hence for multi-party PPRL applications with many parties it is promising to determine partial matches for a sub-set of parties and consider additional parties only for these partial matches.  The parties are first arranged into rings of size (with ) based on the value for the parameter , the minimum number of parties per ring (). The value of needs to be carefully chosen, as it has a trade-off between scalability (complexity) and privacy. The higher the value for is, the better the privacy of the protocol because the resulting CBFs are more difficult to exploit with an inference attack (by mapping the CBFs to known values in a global database to infer their underlying unencoded values), as will be discussed in Section  . On the other hand, higher values of results in lower scalability to large datasets across many parties because the number of comparisons required per ring exponentially increases with the ring size .   []{}">
  <outline text="Sequential communication" _note="In this first proposed communication pattern (SEQ), which requires a , the matches found in one ring are compared with the candidate sets in the next ring resulting in a set of matches from both rings which will then be compared with the candidate sets in the following ring, and so on. This communication is carried out sequentially until the matches from all rings are found by the . Figure   illustrates the SEQ approach for four rings with parties in each ring.  [0.47]{}[c @ lll]{}    \ \ \  \ \ [- :]{} &amp;\ [- :]{} &amp;\ [- :]{} &amp;\ \ [- :]{} &amp;\ 1:&amp;; &amp;//initialize , \ 2:&amp;&amp;//group parties\ 3:&amp;**for** **do**:&amp;//iterate rings\ 4:&amp;   **for** **do**:&amp;//iterate parties\ 5:&amp;      &amp;//party ’s records\ 6:&amp;      **for** **do**: &amp;  \ 7:&amp;         **for** **do**: &amp;  \ 8:&amp;            &amp;// of the ring\ 9:&amp;   &amp;//summation\ 10:&amp;   **for** **do**: &amp;  \ 11:&amp;      &amp;  \ 12:&amp;      &amp;//Eq. ( )\ 13:&amp;      **if** **then**:&amp;//a match\ 14:&amp;         &amp;  \ 15:&amp;   &amp; \  \    Algorithm 3 details the steps of the SEQ communication pattern. First the parties are grouped in rings using the function (line 2 in Algorithm 3). Different number of parties () can be grouped into different rings. The value for can be agreed upon by the parties to any value at the trade-off between privacy and scalability, as will be discussed in Section  .  To minimize the number of comparisons that are required, the grouping of parties into rings is ideally done in an ascending order of the size of their datasets. In this way, the first ring will generate a smaller number of matches, which then have to be compared with the candidate sets in the following rings. This reduces the computational complexity compared to initially larger number of matches being generated by the first ring if the parties in the first ring are the ones with the largest databases.  A loop is iterated over rings in line 3 of Algorithm 3 and then the parties in rings are iterated in line 4. Each party in retrieves its records in line 5 and a loop is iterated over these records in line 7 to append each of them to every candidate record set (from previous party, except for the first party that appends to empty sets) stored in (line 8). Next, a secure summation protocol is applied in line 9 using function on the candidate sets of BFs identified in in order to generate CBFs for each candidate set. In lines 10-12, each CBF generated is then used to calculate the Dice similarity () of the candidate set () and if the (line 13) then is added into the list of matches identified in the ring (line 14), which will then be used as an input (line 15) in the next ring.  The risk of collusion between parties in order to identify data about another party can be reduced in this approach by using different BF encodings in different iterations. For example, if the encoding used in ring 1 in Figure   is unknown to parties in ring 2, then the collusion between the and parties in ring 2 would not reveal sufficient information to infer the actual values masked in the BFs in ring 1. Hence, parties might wish to be grouped with certain other parties in the same ring for better privacy protection.  [0.47]{}[c @ lll]{}    \ \ \  \ \ [- :]{} &amp;\ [- :]{} &amp;\ [- :]{} &amp;\ \ [- :]{} &amp;\ 1: &amp; &amp;//group parties\ 2: &amp; **for** **do**:&amp;//phase 1\ 3: &amp;    ; ; &amp;  \ 4: &amp;    **for** **do**:&amp;//iterate parties\ 5: &amp;       &amp;  \ 6: &amp;       **for** **do**: &amp;  \ 7: &amp;          **for** **do**: &amp;  \ 8: &amp;             &amp;// in the ring\ 9: &amp;    &amp;//summation\ 10: &amp;    **for** **do**: &amp;  \ 11: &amp;       &amp;  \ 12: &amp;       &amp;//Eq. ( )\ 13: &amp;       **if** **then**:&amp;//a match\ 14: &amp;          &amp;// in the ring\ 15: &amp; ; &amp;//initialize\ 16: &amp; **for** **do**:&amp;//phase 2\ 17: &amp;    &amp;  \ 18: &amp;    **for** **do**: &amp;  \ 19: &amp;       **for** **do**: &amp;  \ 20: &amp;          &amp;// in all rings\ 21: &amp; &amp;//summation\ 22: &amp; **for** **do**: &amp;  \ 23: &amp;    &amp;  \ 24: &amp;    &amp;//Eq. ( )\ 25: &amp;    **if** **then**:&amp;//a match\ 26: &amp;       &amp;// in all rings\  \  ">
  </outline>
  <outline text="Ring by ring communication" _note="In the absence of a trusted , as is required by the previously described SEQ communication approach, we propose a ring by ring communication pattern (RBR) for comparing CBFs from multiple parties without using a . This method is illustrated in Figure   for three rings with parties in each ring, while Algorithm 4 outlines the steps of RBR in detail. Similar to SEQ, parties are grouped into rings using the function (line 1 in Algorithm 4). The value for in RBR should be set to , as a minimum of three parties are required in each ring to perform secure summation without a .  The RBR method consists of two phases. In the first phase (lines 2-14 in Algorithm 4), the parties in each ring (lines 2-4) individually perform secure summation among them using (line 9) on their sets of candidate records (generated in lines 5-8) to generate the CBFs , and calculate their similarities to identify matches in each ring (as shown in lines 10-14). In the second phase in lines 16-26, all parties then perform secure summation among them on the matches identified in each ring in order to identify matches from all parties.  Every ring in the first phase can employ a different set of BF parameters to reduce the possibility of collusion between a set of parties in different rings. In the second phase, all parties then have to agree on another set of parameters for BF encodings of the matches identified in rings in the first phase. In addition, the rings in the first phase can be processed independently and in parallel in a distributed environment making the RBR more scalable (than the SEQ) with larger dataset sizes.">
  </outline>
</outline>
<outline text="Analysis of the protocol" _note="In this section we analyze our multi-party PPRL protocol in terms of complexity, privacy, and linkage quality.">
  <outline text="Complexity analysis" _note="We assume parties participate in the protocol, each having a database of records. We assume a private blocking/indexing technique employed in the blocking step forms blocks for each party. In Step 1 of our protocol, the agreement of parameters has a constant communication complexity. Blocking the databases in Step 2 has computation complexity at each party, and finding the intersection of blocks from all parties has a communication complexity of and a computation complexity of at each party, as BKVs need to be securely communicated, and for each of the BKVs a search operation of is required in order to identify the intersection set. Assuming the average number of -grams in the QID attributes of each record is , the masking of QID values of records into BFs of length using hash functions for records in Step 3 is at each party.  Steps 4 and 5 consist of the secure summation of BF vectors to calculate the CBFs of candidate sets. Our extended secure summation protocols HSS and SSS aim to improve privacy at the cost of complexity overhead. The extended HSS protocol requires encrypted values (long integers of 4 bytes each) to be exchanged among the parties, while the basic secure summation (BSS) and SSS require exchanging short integer values (of 2 bytes each), which is more efficient compared to HSS. Further, the homomorphic encryption and decryption functions used in HSS are computationally expensive compared to simple vector addition and subtraction operations .  With the simplified assumption that all blocks are of equal size , i.e. contain BFs at each party, then using the NAI communication method in each block candidate sets of BFs (i.e. all candidate sets of records in a block) have to be generated and their CBFs calculated. The first party performs summations, the second party , and finally summations are performed by the last party, leading to a total of summations in Step 4.  In Step 5, either the linkage unit or the first party that initiated the secure summation protocol performs a vector subtraction operation (subtracts the random vectors from the summed vectors) on all the candidate sets, resulting in CBFs. The similarities of these CBFs are then calculated and matches classified, which requires computations. This combinatorial complexity currently limits the NAI linkage to a small number of parties or a large number of small blocks (i.e.  or has to be small).  The communication patterns SEQ and RBR proposed in Sections   and  , respectively, improve Steps 4 and 5 significantly (depending on the number of parties per ring, ) by reducing the computation and communication complexities. In general the complexities are reduced from the exponential growth with down to in SEQ and in RBR. With the simplified assumption that each ring has parties, the computation and communication complexities of the SEQ and RBR methods are as follows.  In the SEQ method, candidate sets are processed in the first ring and in each of the remaining rings (i.e. matching sets, in the worst case, from the previous ring are compared with the sets in each ring), resulting in total computation and communication complexities of + (with ). The computation and communication complexities of the RBR method is + , where the first phase requires total candidate sets to be processed in each of the rings and the second phase compares the matching sets from each ring.  Overall, the complexity of the NAI method is , the SEQ method is , and the RBR method is . This theoretical analysis shows that the two proposed communication methods SEQ and RBR are computationally efficient compared to the NAI method. Depending on the values for and , the SEQ and RBR methods outperform each other.  The memory size required for a CBF is , which is , bits for every position in the CBF. If the length of CBF is , the total memory consumption is . For BFs the memory required is bit for every position in the BF, and therefore the total memory consumption of . CBF requires relatively more memory than using BFs when is small, however with increasing number of in multi-party PPRL, a CBF requires significantly lower memory compared to BFs. For example, when and the respective memory sizes of a CBF and corresponding BFs are bits and bits, while for and they are bits and bits, respectively.">
  </outline>
  <outline text="Privacy analysis" _note="As with most of the existing PPRL approaches, we assume that all parties follow the honest-but-curious (semi-honest) adversary model , where the parties follow the protocol while being curious to learn the other parties’ data by means of inference attacks on input data  or collusion . To analyze the privacy against inference attacks, we discuss what the parties can learn through inference attacks or collusion during the protocol. We assume a trusted is available, which does not collude with any parties, as is commonly used in many practical PPRL applications .  However, collusion among the database owners is a privacy risk in the basic secure summation protocol where a set of parties can collude to learn the BF of another party using their received summation values. To overcome this problem, in Section   we have proposed two extended secure summation protocols, HSS and SSS. The HSS protocol uses homomorphic encryptions for secure summation which makes the protocol more secure because without knowing the private key (which is only known to the ) identifying a party’s BF values by means of collusion will not be successful. However, this protocol encrypts each integer value in a BF (in total values for each BF) into a hash key (long integers) and thus incurs a very large communication overhead making the protocol not viable for linkage of multiple large databases. The SSS protocol similarly makes the protocol more secure by adding additional integer values as salting keys by each party individually (known only to the ) in the secure summation, such that without knowing the salting key value collusion among parties to learn a party’s BF is not possible. Compared to HSS, the SSS approach does not incur any expensive communication overhead as the salting keys are small integer values.  Communication occurs among the parties in Step 1 of our protocol (as described in Section  ) where they agree on parameter settings, and in Steps 4 and 5 where they participate in a secure summation protocol. The agreement of parameter settings in Step 1 does not reveal any sensitive information about the underlying data. Secure summation involves partial (masked) data exchange where the parties communicate the partial and full summations of their BFs (1) among them in Step 4 and (2) to the or the first party that initiated the communication in Step 5, respectively, to calculate the CBFs of the candidate sets and their similarities.  The (in SEQ or NAI) or the first party in each ring (in RBR) receives the CBFs of candidate sets in each ring. Compared to calculating similarities of sets using their BFs directly, using a CBF makes the inference attack on individual BFs and thus their -grams (strings) mapped into them more difficult. An inference attack allows an adversary to map a list of known values from a global dataset (e.g. -grams or attribute values from a public telephone directory) to the encoded values (BFs or CBF) using background information (such as frequency) . The only information that can be learned from such an inference attack using a CBF of a set of BFs (summed over parties, where either in NAI and RBR methods or in SEQ and RBR methods) is if a bit position in is either or which means it is set to or , respectively, in the BFs from all parties.  The probability of identifying the original (unencoded) values of () individual records (with ) given a single CBF is smaller than the probability of identifying the original (unencoded values) of given individual BFs , .  Assume the number of original (unencoded) values that can be mapped to a masked BF pattern from an inference attack is . in the worst case, where a one-to-one mapping exists between the masked BF and the original unencoded value of . The probability of identifying the original value given a BF in the worst case scenario is therefore . However, a CBF represents BFs and thus at least (in the worst case) original (unencoded) values, which leads to a maximum of with (when , ). Hence, .  We will empirically evaluate and compare the amount of privacy provided by masking records into CBFs and BFs against an inference attack in Section  . A larger number of parties in a ring (i.e. the larger the value for ) results in an increase in the difficulty of an inference attack (a smaller probability of suspicion ) by the adversary ( or the first party in each ring for SEQ and RBR, respectively) at the cost of more candidate set comparisons.  Further, using different hash encodings by different rings in our SEQ and RBR methods improves privacy compared to the NAI method by reducing the possibilities of collusions, as discussed in Section  . Since the hash functions used by parties in ring 1, for example, are not known to parties in other rings, a collusion between parties in other rings and / or the will not be successful in inferring the original values of parties in ring 1. A careful grouping of parties is therefore required to improve privacy in a multi-party setting (for example, randomly groups or changes the grouping for different blocks). More specifically, when parties are involved in the linkage, the maximum number of possible combinations for collusion in NAI method is , while in SEQ and RBR it is . For example, with parties the NAI method has possibilities to collude while grouping into equal sized rings () leads to only different collusion possibilities.  The values for the number of hash functions used () and the length of the BF () provide a trade-off between the linkage quality and privacy . The higher the value for , the higher the privacy and the lower the quality of linkage, because the number of -grams mapped to a single bit (and therefore the number of resulting collisions) increases, which leads to lower linkage quality but makes it more difficult for an adversary to learn the possible -gram combinations . The CLK encoding method (as discussed in Section  ) of hash-mapping several QID values from each record into one compound BF  makes it even more difficult for an adversary to learn individual QID values that correspond to a revealed bit pattern in a BF.">
  </outline>
  <outline text="Linkage quality analysis" _note="Our protocol supports approximate matching of QID values, in that data errors and variations are taken into account depending on the minimum similarity threshold used. The quality of BF-based masking depends on the BF parameterization . For a given BF length, , and the number of elements (e.g. -grams) to be inserted into the BF, the optimal number of hash functions, , that minimizes the false positive rate (of a collision of two different -grams being mapped to the same bit position), is calculated as  , leading to a false positive rate of .  While and determine the computational aspects of BF masking, linkage quality and privacy will be determined by the false positive rate . A higher value for will mean a larger number of false matches and thus lower linkage quality . In our experimental evaluation we will set the BF parameters for our approach according to the discussion presented here and following earlier BF work in PPRL .">
  </outline>
</outline>
<outline text="Experimental evaluation" _note="In this section, we empirically evaluate the performance of our protocol (which we refer as AM-CBF for Approximate Matching with Counting BFs) with the SEQ, RBR, and NAI communication patterns in terms of the three properties of PPRL, scalability (complexity), linkage quality, and privacy. We describe the competing baseline methods in Section  , the datasets used in Section  , the evaluation measures in Section  , and the experimental settings in Section  . We then discuss the experimental results in Section  .">
  <outline text="Baseline methods" _note="We use Lai et al. ’s exact matching BF-based PPRL approach (referred as EM-BF for Exact Matching with BFs) and Vatsalan and Christen ’s approximate matching BF-based PPRL approach (AM-BF for Approximate Matching with BFs) as competing baseline methods to compare with our proposed approach. Since other existing approaches for multi-party PPRL (as reviewed in Section  ) are either based on expensive cryptographic techniques or applicable to categorical data only, we do not compare them with our approach.  Lai et al.’s EM-BF approach  performs exact matching of QIDs across multiple parties using BFs. In their approach, the QID values of all records in a dataset are first converted into one BF. Each party then partitions its BF into segments according to the number of parties involved in the linkage, and sends these segments to the corresponding other parties. The segments received by a party are combined using a conjunction (logical AND) operation. The resulting conjuncted BF segments are then exchanged between the parties to construct the full conjuncted BF. Each party checks its own full BF of each record with the conjuncted BF, and if the membership test is successful then the record is considered to be a match. Though the cost of this approach is low since the computation is completely distributed between the parties and the processing of BFs is fast, the approach can only perform exact matching.  Vatsalan and Christen proposed AM-BF  by adapting the idea used in EM-BF of distributively computing the conjunction of a set of BFs from multiple parties to perform privacy-preserving approximate matching for multi-party PPRL. Once the conjuncted BF segments are computed by the respective parties, a secure summation protocol is initiated among the parties to securely sum the number of common -bits in the conjuncted BF segments as well as the total number of -bits in each party’s BF. These two sums are then used to calculate the Dice coefficient similarity of the set of BFs. A filtering approach is employed to reduce the number of comparisons based on segment similarity, such that if a sub-set of BF segments of a candidate set (as calculated by a respective party) has lower similarity then the BFs do not have to be compared with any of the BFs from the other parties.  Both EM-BF and AM-BF approaches use the NAI method for comparing and classifying candidate sets of records.">
  </outline>
  <outline text="Datasets" _note="To provide a realistic evaluation of our approach, we based all our experiments on a large real-world database, the North Carolina Voter Registration (NCVR) database as available from `ftp://alt.ncsbe.gov/data/`. This database has been used for the evaluation of various other PPRL approaches . We have downloaded this database every second month since October 2011 and built a combined temporal dataset that contains over 8 million records of voters’ names and addresses . We are not aware of any available real-world dataset that contains records from more than two parties that would allow us to evaluate multi-party PPRL approaches. We therefore generated, based on the real NCVR database, a series of sub-sets for multiple parties, as will be described next.  To allow the evaluation of our approach with different number of parties, with different dataset sizes, and with data of different quality, we used and modified a recently proposed data corruptor  to generate various datasets with different characteristics based on randomly selected records from the NCVR database. The identifiers of the selected and modified records were kept the same, which allows us to identify true and false matches and therefore evaluate linkage quality, as described below. Specifically, we extracted sub-sets of , , , , , and records from the NCVR to generate datasets for , , , and parties, where the number of matching records is set to 50% (i.e. half of selected records occur in the datasets of all parties).  To evaluate how the approaches work with ‘dirty’ data, we created several series of datasets for each of the datasets generated above, where we included a varying number of corrupted records into the sets of overlapping records (, , and ). We applied various corruption functions on randomly selected attribute values, including character edit operations (insertions, deletions, substitutions, and transpositions), and optical character recognition and phonetic modifications based on look-up tables and corruption rules . This means that a certain percentage of records in the overlap were modified for randomly selected parties, while the original values were kept for the other parties. Therefore, some of these records are exact duplicates across some parties in a set, but are only approximately matching duplicates across the other parties in the set. This simulates, for example, the situation where three out of five hospitals have the correct and complete contact details (like name and address) of a certain patient, while in the fourth and fifth hospitals some of the details of the same patient are different.">
  </outline>
  <outline text="Evaluation measures" _note="We evaluate the three properties of PPRL using the following evaluation measures. The complexity (scalability) of linkage is measured by RUNTIME, COMMUNICATION SIZE, and the NUMBER OF COMPARISONS required for the linkage. The quality of the achieved linkage is measured using the F-MEASURE, calculated on classified matches and non-matches, that has widely been used in record linkage, information retrieval and data mining .  In line with other work in PPRL , we evaluate privacy using disclosure risk (DR) measures based on the probability of suspicion, i.e. the likelihood a masked (encoded) database record in can be matched with one or several (masked) record(s) in a publicly available global database . The probability of suspicion for a masked value/record , , is calculated as where is the number of possible matches in to the masked value . We conducted a frequency linkage attack  by mapping the exchanged bit information in the BFs generated from to the BFs generated from . We used the worst case scenario where , because when there will be a one-to-one exact matching of a global value for each value in . Based on such linkage attack, we calculate the following disclosure risk measures, as proposed by Vatsalan et al. .  MEAN DISCLOSURE RISK (): This calculates the average risk ( ) of any sensitive value in being re-identified.  MARKETER DISCLOSURE RISK (): This is calculated as the proportion of masked records in that match to exactly one masked record in ().">
  </outline>
  <outline text="Experimental settings" _note="We implemented both our proposed approach and the competing baseline approaches in Python 2.7.3, and ran all experiments on a server with four 6-core 64-bit Intel Xeon 2.4 GHz CPUs, 128 GBytes of memory and running Ubuntu 14.04. The programs and test datasets are available from the authors.  Following the discussion in Section   and other work in PPRL , we set the parameters as BF length , the number of hash functions , the length of grams , the minimum similarity threshold , and the number of parties . For the SEQ method the minimum number of parties per ring was set to and for the RBR method . The attributes first name, last name, city, and zipcode were used as the QIDs in the linkage. We applied a Soundex-based phonetic blocking  for the private blocking step in all approaches, which results in a set of blocks on which we individually conduct private comparison and classification.  The experiments are two-fold. In the first part we evaluate the scalability of our approach with proposed communication patterns and compare with the NAI method. In the second part we compare the complexity, linkage quality, and privacy of our approach (with the SEQ approach as it gave the best results in the first part) with baseline methods. We used the first name and last name attributes as the blocking keys in the second set of experiments and all four attributes in the first set of scalability experiments in order to allow for comparative evaluation with the NAI method (as we were unable to run experiments for the NAI method on larger datasets with larger when only two blocking attributes were used).  [c|ccc]{}\   &amp;  Runtime (sec)  &amp;  Size (MBytes)  &amp;  F-measure \ \ BSS &amp; &amp; &amp; \ HSS &amp; &amp; &amp; \ SSS &amp; &amp; &amp; \ ">
  </outline>
  <outline text="Discussion" _note="Table   shows the runtime and memory size required and the F-measure results achieved with the three secure summation protocols. As can be seen, the HSS requires significantly higher runtime and memory (which is not practical in real applications) to improve privacy against collusion attacks on the BSS without compromising the F-measure results. However, the SSS approach requires similar runtime and memory as the BSS for improving privacy against collusions with no loss in linkage quality. We therefore use SSS in all following experiments.                    Figures   (a) and (b) show the complexity of our AM-CBF approach with the proposed communication patterns SEQ and RBR in terms of runtime and communication size (comm), while Figure   (c) shows the runtime and communication size required by the NAI communication pattern. As the figures show the proposed communication methods improve the scalability of our multi-party approach by significantly reducing the number of candidate sets (and thereby the complexities) compared to the NAI method (which has been used in many existing solutions including the baseline approaches). As discussed in Section  , SEQ is faster than RBR (Figure   (a)). When , RBR is equivalent to NAI (as we set ). Both SEQ and RBR are scalable (almost linear) with the dataset size and the number of parties compared to the NAI method that increases exponentially with the number of datasets and their sizes. We were unable to conduct linkage experiments using the NAI method for larger and dataset sizes due to its exponential complexity (and thus some data points for the NAI method are missing in Figure   (c)).  Figure   (d) shows the number of candidate sets to be compared and classified using our AM-CBF approach. The number of candidate sets with the NAI method grows exponentially with the size of the datasets for increasing , as can be seen when . In Figures   (e) and (f), we compare the complexity requirements of the SEQ and RBR methods with different ring sizes based on on the NCVR-10,000 datasets for parties. We evaluated the SEQ method with and the RBR method with ( in RBR). This provides ring sizes of  ,  ,  , and   for , , , and , respectively. As shown in the figures, the complexity increases with larger ring sizes, because larger ring sizes mean more comparisons are required in each ring.  We compare the runtime required by our approach (with SEQ) with the baseline approaches on the NCVR-10,000 and 50,000 datasets in Figure   (a). Though the baseline approaches require lower runtime for linking datasets than our approach (because the matches identified in one ring need to be compared again with the candidate sets in the other rings in our approach), they are not scalable to more parties () and larger datasets. We were unable to conduct experiments for AM-BF with and EM-BF with on the NCVR-50,000 datasets due to the exponential increase in the number of candidate sets generated. As can be seen in Figure   (a), our approach is scalable and requires significantly lower runtime for linking and datasets compared to the baseline approaches.  As shown in Figure   (b), our approach outperforms the baseline EM-BF and AM-BF approaches in terms of linkage quality measured by F-measure. The filtering approach used in AM-BF results in lower F-measure compared to our approach. The F-measure is high on the non-modified datasets (0% corruption), while it drops with on the modified (20% and 40%) datasets as the number of missed true matches increases when records are modified in each dataset. However, our AM-CBF approach achieves the highest F-measure on both modified and non-modified datasets (though EM-BF performs equally well on the non-modified datasets).  Finally, we compared the DR measures of privacy for our approach based on CBF masking with baseline approaches based on BF masking in Figures   (c) and (d). The results show that the DR measures with our approach are consistently lower (and thus privacy is higher) than the baseline approaches. As expected, the DR measures also decrease with larger (as discussed in Section  ), and with more corruptions in the dataset because corrupted records reduce the probability of mapping to matching global values in to allow the records to be re-identified.">
  </outline>
</outline>
<outline text="Related Work" _note="Various techniques have been proposed in the literature tackling the problem of PPRL . However, most of them consider linking two databases only, and a only few approaches have been proposed for PPRL on multiple databases.  An SMC-based approach using an oblivious transfer protocol was proposed by O’Keefe et al.  for PPRL on multiple databases. While provably secure, the approach only performs EXACT MATCHING of masked values (i.e. variations and errors in the QIDs are not considered) and it is COMPUTATIONALLY EXPENSIVE compared to efficient perturbation-based privacy techniques, such as BFs and -anonymity . A multi-party -anonymity-based PPRL approach was introduced by Kantarcioglu et al. . In their apporach, a secure equi-join (EXACT MATCHING) is applied on the -anonymized databases by a to identify matching records.  A multi-party PPRL approach for approximate matching of CATEGORICAL VALUES was proposed by Mohammed et al. , where a top-down generalization is performed to provide -anonymous privacy and the generalized blocks are then classified into matches and non-matches using the C4.5 decision tree classifier. Another efficient multi-party approach for CATEGORICAL DATA was recently proposed by Karapiperis et al.  using a Count-Min sketch data structure. Sketches are used to summarize the local set of elements which are then intersected to provide a global synopsis using homomorphic operations, secure summation, and symmetric noise addition privacy techniques.  As described in Section  , Lai et al. ’s approach uses efficient Bloom filter encoding for masking string data in multi-party PPRL. However, the approach performs only EXACT MATCHING. This approach has been adapted by Vatsalan and Christen  for APPROXIMATE MATCHING in multi-party PPRL (as described in detail in Section  ). Several approximate comparison functions for calculating similarities of PAIRS of string and other data types have been proposed for PPRL by adapting existing comparison functions.  A secure version of the Levenshtein edit distance was proposed by Karakasidis and Verykios  using CBFs, where the elements of a string are checked against a CBF of another string to count the number of edits, while the CBF also provides the length of the string masked into it. However, developing privacy-preserving comparison functions for multiple (more than two) values has only recently been considered by Vatsalan and Christen  using the Dice coefficient similarity.  Scalability has been addressed by using private blocking functions and / or filtering approaches  as well as by parallelizing and / or distributing the tasks among several nodes or parties . The scalability problem in multi-party PPRL has only recently been focused on. Ranbaduge et al.  proposed a family of efficient tree-based private blocking techniques for multi-party PPRL using BF encoding and secure summation. Several filtering approaches have been used in PPRL of two sources, including length filtering in BFs  and PPJoin techniques . The recently proposed multi-party BF-based PPRL approach  (described above) employs a filtering approach based on the similarity of segments of BFs. However, the NUMBER OF COMPARISONS required for multi-party linkage REMAINS VERY LARGE even with existing private blocking and filtering approaches employed . Therefore, efficient multi-party filtering and communication patterns need to be developed in order to make PPRL scalable and viable in practical applications.  Several query tree representations have been used for optimizing multi-way join queries . Schneider and DeWitt  studied query processing plans with different types of structures, left-deep, right-deep, and bushy. Left-deep and right-deep trees use a base table as the inner and outer operand, respectively, of each join in the plan, while in bushy trees both inputs to a join may themselves result from joins. However, these techniques have not been used for efficient processing of multi-party PPRL.">
</outline>
<outline text="Conclusion" _note="We have presented an efficient and scalable protocol for PPRL of multiple databases with two improved communication patterns. Our approach performs approximate matching on the QID values (of string data) masked using efficient and simple privacy techniques, counting BFs and secure summation. Experiments conducted on real datasets showed the efficiency and scalability of our approach compared to two baseline approaches while achieving superior results in terms of linkage quality and privacy.  In future work, we plan to investigate other improved communication patterns, collision resistant secure summation protocols, and different approximate string comparison functions  to be incorporated. We also aim to develop efficient PPRL techniques for identifying matching record sets within sub-sets of parties, which is an important research problem.  Another research direction would be to develop multi-party PPRL approaches under other adversary models such as the covert model  or accountable computing  (where honest parties can verify fake data from dishonest parties with high probability) to overcome the limitations of the semi-honest (HBC) adversary model. Finally, we plan to investigate improved classification techniques for multi-party PPRL including relational clustering and graph-based approaches  which are successfully used in non-PPRL applications.">
</outline>
<outline text="Acknowledgments" _note="This work was partially funded by the Australian Research Council (ARC) under Discovery Projects DP130101801 and DP160101934, and Universities Australia and the German Academic Exchange Service (DAAD).">
</outline>
  </body>
</opml>