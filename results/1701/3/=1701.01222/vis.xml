<?xml version="1.0" encoding="UTF-8"?>
<opml version="2.0">
  <head>
    <title>Vizic: A Jupyter-based Interactive Visualization Tool for Astronomical
Catalogs</title>
    <abstract>The ever-growing datasets in observational astronomy have challenged
scientists in many aspects, including an efficient and interactive data
exploration and visualization. Many tools have been developed to
confront this challenge. However, they usually focus on displaying the
actual images or focus on visualizing patterns within catalogs in a
predefined way. In this paper we introduce VIZIC, a Python visualization
library that builds the connection between images and catalogs through
an interactive map of the sky region. VIZIC visualizes catalog data over
a custom background canvas using the shape, size and orientation of each
object in the catalog. The displayed objects in the map are highly
interactive and customizable comparing to those in the observation
images. These objects can be filtered by or colored by their property
values, such as redshift and magnitude. They also can be sub-selected
using a lasso-like tool for further analysis using standard Python
functions and everything is done from inside a Jupyter notebook.
Furthermore, VIZIC allows custom overlays to be appended dynamically on
top of the sky map. We have initially implemented several overlays,
namely, Voronoi, Delaunay, Minimum Spanning Tree and HEALPix grid layer,
which are helpful for visualizing large-scale structure. All these
overlays can be generated, added or removed interactively with just one
line of code. The catalog data is stored in a non-relational database,
and the interfaces have been developed in JavaScript and Python to work
within Jupyter Notebook, which allows to create customizable widgets,
user generated scripts to analyze and plot the data selected/displayed
in the interactive map. This unique design makes VIZIC a very powerful
and flexible interactive analysis tool. VIZIC can be adopted in variety
of exercises, for example, data inspection, clustering analysis, galaxy
alignment studies, outlier identification or just large scale
visualizations. </abstract>
  </head>
  <body>
<outline text="Introduction" _note="For the past decades, conducting large-area sky surveys became one of the most powerful approaches to carry out observations within the astronomy community in order to understand the Universe. The Sloan Digital Sky Survey (SDSS) set the foundations for such surveys followed by others, such as DES and Pan-STARRS . Modern telescopes and world-class supercomputing facilities produced exceptionally good images and exceptionally precise measurements of astrophysical sources, challenging astronomers to face unprecedentedly massive datasets. Moreover, future large sky, for example, LSST and Euclid , will obtain data of orders of magnitude larger than what we have today. These massive datasets place a new challenge on astronomers in the light of data exploration and visualization.  Various groups and individuals have tried to confront this challenge by developing new astronomical applications that are capable of displaying and visualizing large datasets. Notable examples include ALADIN LITE , VISIOMATIC , ASCOT and TOYZ , to mention just a few. The majority of these softwares are web-based applications that focus on the visualization of high-resolution images with additional functionalities of catalog over-plotting or image analysis. Meanwhile, GLUE , a desktop application that specializes in visualizing selection propagations between different plots of the same dataset, has became a popular tool for exploring hidden patterns within catalogs and images. Unfortunately all these mentioned tools, while being very powerful, have some drawbacks when it comes to the study of large-scale structure and flexible customization. Image-focused applications are limited by the fundamental characters of photometric observations, whereas images produced by sky surveys are fixed in terms of compositions, in other words, the sources are immoveable. In this regard, catalogs are more flexible considering astronomical sources in a catalog can be easily sorted and filtered. However, tools that are more friendly with tabular data are usually less good at interactive visualizations of geospatial data. They either render data points into simple scatter plots or summarize data distribution into pixels like with VAEX , which lacks rich interactions with individual object while providing a very powerful way to visualize distributions of extremely large catalogs. The regarding limitations of existing softwares in addition to emerging new technologies for building interactive web tools have generated a need to improve existing tools and develop new ones.  Thanks to the increasingly powerful web technologies (e.g., HTML5 , CSS and JavaScript ) and the improved data bandwidth, nowadays much more complex tasks can be carried out in a browser. Along with the great availability of graphic design JavaScript libraries, web browser has became a fertile ground for visualization projects. In addition, thanks to projects like Jupyter we now have the powerful combination of a web-based application that can run anywhere with the flexibility of a Python scripting environment where scientist can customize plots, algorithms and workflows only restricted by the limitations of the programming language.  Considering astronomers are usually experienced scripting programmers (but less so in web development) and the fact that Python is one of the most common languages used today, we have created VIZIC, a Jupyter-based interactive visualization tool, which is a Python package designed to work with the Jupyter Notebook App. This tool (formally IPython Notebook) is a server-client application that allows creating and running Jupyter notebooks in which Python code can be executed interactively in executable cells. Unlike other existing tools, VIZIC tries to make the connection between a source catalog and its images by drawing astronomical sources on an interactive map, where we can clearly visualize the spatial distribution of the observed objects, and at the same time keeping full control over the compositions, through objects filtering, color mapping, over plotting layers, among other useful features to visualize patterns on the data in a much more efficient manner. Since Jupyter Notebook App is a server-client system, VIZIC can be used for accessing data archives at remote locations as well as working with catalogs stored on a local machine. Regarding the rising popularity of Jupyter Notebook App within the science community, we believe in providing an interactive interface without limiting the scripting ability to extend and to use this package, which will enable a faster scientific discovery.  The rest of the article is organized as follows. In Section  , we start with a brief introduction to VIZIC and highlight some of its important features. In Section  , we discuss the technical details regarding the architecture and dependencies of VIZIC. In Section  , we present an example application of VIZIC in visualizing large-scale structure. Section   provides the installation instruction, and Section   assesses the performance of VIZIC with various loads. Lastly, in Section  , we gives the conclusions, and describes future plans and possible extensions.">
</outline>
<outline text="Vizic" _note="VIZIC is a Python and Javascript library, which provides the API to display and interact with sky maps created from catalogs within Jupyter notebooks. At the front-end, the interactive sky maps are generated using LEAFLET[^1] , a popular JavaScript library for building interactive map applications on the web, and rendered through the widget framework provided by IPYWIDGETS[^2] , which is a library of interactive HTML widgets for Jupyter notebooks and IPython kernels. VIZIC works side by side with MongoDB[^3] , therefore an active MongoDB instance, either running in the background or in a remote location (see Figure   for a workflow diagram), is required when VIZIC is used. MongoDB is a non SQL, document-oriented database, which is built for scalability and performance. Since the data is stored in documents instead of multiple tables with complex relations, MongoDB database can spread the data over different servers and nodes. In the case of storing simple astronomical catalogs, MongoDB is particularly suitable. MongoDB also provides a geospatial index for making extremely efficient location-based queries. The rational to use MongoDB is discussed in more detail in Section  .  The interactive sky maps can be easily created from catalogs stored in pandas DataFrames or catalogs that are previously ingested into the database by providing the collection names. Data stored in other formats, for example, ASTROPY Table object, can also be fed into VIZIC after a simple conversion to pandas DataFrame. A PANDAS DataFrame is a Python object that handles arrays and tabular data very efficiently.[^4] When a DataFrame is provided, VIZIC will format the data to match the mapping mechanism used, which is described in more detail in Section  . In the sky maps, astronomical objects are drawn using their shapes, sizes and rotation angles determined by source catalog extractor softwares such as SEXTRACTOR to cite an example. If relevant shape information is not available, the objects will be drawn as filled circles with appropriate radius provided in the catalog. If neither the shape data nor the size data is provided, the objects will be drawn as filled circles with a fixed radius of pixel at the minimum zoom level, however alternative sizes can be specified as an argument, and scaled up as the map is zoomed in.  There are two main categories of widgets provided by VIZIC, namely, map widgets and control widgets. Map widgets are responsible for creating and managing sky maps and overlays. The core map widgets include `AstroMap` and `GridLayer`. The `AstroMap` widget is the container for all map layers, and the `GridLayer` widget is the tile-based layer for displaying the astronomical sources or simply the catalog layer. Additional custom overlay widgets are also provided for aid in visualizing large-scale structure (see Section  ). The control widgets are the main interfaces that take advantage of the extensive interactivity of the displayed objects (see Section  ). For example, through control widgets, we can filter the displayed objects by their property values and apply custom colormaps to these sources. These control widgets do not possess mutual reliance, therefore they can be used independently from each other. Such a modularized design brings a much cleaner graphical user interface (GUI) comparing to other tools. Users can create their own application and interface by selecting only the needed components and interact with the data and the maps from within the Jupyter notebooks. After all, VIZIC provides the foundation for a complete and customizable analysis, which is complementary to the standard scripting analysis workflows.  [^1]: http://leafletjs.com/  [^2]: https://ipywidgets.readthedocs.io/en/latest/  [^3]: https://www.mongodb.com/  [^4]: http://pandas.pydata.org">
  <outline text="Sky Maps" _note="Before any sky maps can be created, the connection to a running MongoDB instance has to be established. The connection could be initiated by creating a `Connection` class object with a URL that specifies the address of the MongoDB instance and a port number. In the background, the IPython kernel creates a MongoDB client using the provided information and assigns the client to an attribute of the `Connection` object, which is required for creating `GridLayer` widgets. After the connection is successfully established, the `AstroMap` widget and the `GridLayer` widget instances can be created by initializing the corresponding Python object. To display catalogs in the notebook cells, we need to add the `GridLayer` widget to the `AstroMap` widget using the `add_layer` function. Then we can zoom and pan the map interactively as with a Google Map[^1] The transformation of the celestial coordinates is accomplished by a customized coordinate reference system (CRS) JavaScript library that determines the projection scale based on the extent of the map measured in degrees. In this manner, we can use RA and DEC information from the sources directly.  When creating catalog layers from PANDAS DataFrames, the default columns used for reading the locations are the standard RA and DEC. The default columns used for reading the shape and orientation of each object are A\_IMAGE, B\_IMAGE, THETA\_IMAGE, which are respectively the semi-major axis, semi-minor axis and the rotation angle used in the Scalable Vector Graphics (SVG) ellipse adopted to represent that object. This process is repeated for every object in the catalog. Different column names can also be specified in the arguments for reading this information.  [^1]: https://www.google.com/maps">
  </outline>
  <outline text="Interaction">
  </outline>
  <outline text="Custom Overlay">
  </outline>
</outline>
<outline text="Architecture &amp;amp; Dependencies">
</outline>
<outline text="Example Application" _note="In this section, we present an example usage of VIZIC in scientific research. We first create an interactive map using a subset of the spectroscopic catalog from SDSS Data Release 13 (DR13) . This subset covers the area from to in right ascension and from to in declination with a total of nine square degrees. This sample catalog contains only the objects from the redshift bin . For demonstration purpose, we choose not to provide the shape and size information when creating the sky map.  Then we look for galaxy clusters and voids on the sky map and mark them with circle layers using different colors. For the sake of this example, the positions and sizes are selected by eye. The approximated centers of the clusters and voids are determined by the mouse position tracker located on the bottom left corner of the map (See Figure  ). Next, we apply the MST overlay onto the sky map. By pruning the tree with different combination of and , we can confirm our previous structure selections with the tree groups that are kept. We can observe that for a more strict cut in , i.e. reducing maximum linkage length between two points, as shown in Figure  , compact structures selected by the MST are correlated to those circles shown in green (i.e., clusters), while for a more relaxed cut, in Figure  , the structures shown follow the underlying filament structure around voids (white circles) much better.  Additionally, other layers can be over-plotted, data can be selected for further inspection, objects can be filtered, colored and scaled to aid with visualization and analysis. Multiple maps, multiple cuts and multiple datasets can be used interactively with other scripting procedures and functions on the data from other cells in one single Jupyter notebook, increasing the potential and effectiveness of VIZIC.">
</outline>
<outline text="Distribution &amp;amp; Installation" _note="VIZIC is registered with Python Package Index[^1], therefore it can be installed with PIP for Python 3. It can also be installed from source code by downloading the GitHub repository[^2]. VIZIC requires a running MongoDB instance, the installation and setup instructions can be found from the official MongoDB website[^3]. More detailed instructions on the installation of VIZIC and its required dependencies as well as tutorials, API documentation and examples can be found in the official VIZIC documentation[^4].  Instead of installing the package in a local machine and keeping a MongoDB instance running, the user can also build a Docker[^5] container from the Dockerfile included in the GitHub repository. Both the MongoDB database and the Jupyter notebook server run inside the container with only designated ports exposed to the host for easy deployment. An example dataset and notebooks are included as part of the VIZIC distribution on GitHub as well.  [^1]: https://pypi.python.org/pypi/vizic  [^2]: https://github.com/ywx649999311/vizic  [^3]: https://docs.mongodb.com/manual/  [^4]: http://www.wx-yu.com/vizic/index.html  [^5]: https://www.docker.com">
</outline>
<outline text="Performance &amp;amp; Discussion" _note="Visualizing large datasets through a browser has always been a difficult task. Unlike some of the existing tools, the goal of VIZIC is not to display as many objects as possible at once, but instead to reduce the number of displayed sources without losing important information using the “slippy map” implementation described before.  We set up several tests to examine the overall performance of VIZIC regarding data ingestion and map interaction and deployment. All tests were performed on a Macbook Pro running OS X El Capitan equipped with a 2.5GHz Intel Core i7 (i7-4870HQ) processor, 16Gb of RAM and a SSD. Both MongoDB instance and the Jupyter App server were running locally. Unless specifically stated, VIZIC was tested using the browser Chrome.  Figure   shows the time in seconds for the data ingestion as a function of catalog size (number of objects), and all catalogs ingested in this test contain fifteen columns. The linear baseline shown in this figure is a trendline for the first three data points on this plot. We notice that the actual performance curve starts to deviate from the linear baseline when the catalog size exceeds 3 million. We presume such diverging behavior as a result of computational resources being exhausted.  The second test performed, as shown in Figure  , profiles the timings for map loading triggered when applying interactively different zoom levels. To focus on the effect of catalog sizes on the tiles loading performance, we created the test datasets by continuously and repeatedly throwing a collection of objects onto a area until the desired number of objects is reached, hence increasing the density of the objects each time. This collection of objects were selected from a same area in SDSS Data Release 13.  The tile loading time is a direct indication of the responsiveness of the map when zoom level changes interactively. In our test, we fixed the map window to 512 by 512 pixels and aligned the center of map with the center of the window. Then, four tiles were loaded simultaneously each time the zoom level changes. We used the Chrome DevTool to record the loading time for each tile and take the average as the final result. Accordingly, if more tiles are loaded at the same time, for example, in the full screen mode, the loading performance might differ but follow a similar trend seen in Figure  .  Another critical measurement is the smoothness of the panning motion on the map. Without triggering new tile loadings, the responsiveness of the panning motion is proportional to the number of SVG elements added to the Document Object Model (DOM) tree, the larger the DOM tree the longer it takes to pan the map. In the tests performed above, the tile loadings were usually slower than the panning motion and we didn’t experience any significant lags, where the maximum number of objects loaded in one tile was around fifteen hundred. Nonetheless, higher latencies were observed in the full screen mode, as a direct result of increased number of SVG elements added to the DOM tree.  As shown in the performance tests, the largest catalog being visualized on the mentioned machine include 10 million rows and 15 columns. Due to the constraints of the available hardware, we were not able to further examine the limit of VIZIC. However, we believe VIZIC will perform well with any dataset that has less than 50 million objects, on a more powerful machine. In the future release, we expect to make VIZIC capable of handling catalogs on the order of and above. Currently if a user would like to work with a dataset on that order, we suggest the user to divide the entire dataset into several subareas and then create a map for each subarea. In a case that displaying the whole dataset and observing the big picture is most critical, the users can turn to tools like VAEX, but sacrificing the ability to further interact with the data through object filtering and coloring, as well as the application of custom overlays.  At this stage, the pre-defined custom overlays are not suitable for use on a single large dataset (typically over 100K data points being displayed at a time). However, these overlays could also be made to work by first dividing the region covered by the large catalog into several small areas and then creating a map for each smaller area. If the interesting objects happen to be near the edges of these small maps, the user can use the provided selection tool to query the catalog from the large map and create another new map from it. In the future release of VIZIC, a performance improvement related to the custom overlay is expected.">
</outline>
<outline text="Conclusions &amp;amp; Future Work" _note="In this paper, we present VIZIC, a Python visualization package, which is designed to work with the Jupyter Notebook App. To offer an easy and complete analysis environment, VIZIC utilizes the best part of both images and catalogs by visualizing astronomical sources on an interactive sky map and provides powerful interactions with the Jupyter notebook cells for further interactive scripting analysis with the data.  While resembling the spatial distributions of the sources on the original images, the interactive sky maps created using VIZIC also allow us to filter or color displayed astronomical objects by their property values. The lasso-like selection tool provides us the ability to interactively select interesting objects from the sky map and retrieve their catalog from the linked MongoDB database. Alongside the returned DataFrame containing the catalog for the selected objects, we can further explore and analyze the hidden patterns among the data using various plotting packages available for Python and Jupyter, like MATPLOTLIB, SCIKIT-LEARN and many others. In addition, VIZIC offers us the option to over-plot custom layers on the base map. Four pre-defined custom overlays are included in this package. The Voronoi diagram overlay, the minimum spanning tree overlay and the Delaunay triangulation overlay provide an easy and fast way to visualize cosmological structures. The HEALPix grid overlay is a convenient tool to interactively inspect the density field generated by the catalog or to complement with other astronomical data. VIZIC supports multiple datasets and multiple layers for a full exploration between different catalogs.  We also demonstrate an immediate application of VIZIC by identifying galaxy clusters, voids and filaments. By utilizing the tree pruning feature provided by the minimum spanning tree overlay, we can match the saved tree branches with previously selected structures to visualize and detect these structures. The result shows that VIZIC is a powerful and friendly tool for visualizing large-scale structure. However, its usage is not limited to just galaxy catalogs, any form of catalog data can be easily handled by VIZIC, such as star and galaxy clusters, star forming regions in a galaxy, etc.  In general, VIZIC provides a new way to efficiently visualize and interact with astronomical catalogs. Nevertheless, these features provided by VIZIC can also be applied to data from other scientific fields.  Multiple improvements over the current version has already been planned. A major improvement is to further increase the scalability of this tool. While keep increasing the number of objects that VIZIC can efficiently visualize (with a maximum loading time of 0.5 second for each zoom level), we also would like to match the responsiveness of the custom overlays to that of the tiled base layer. We are currently testing new method of building these overlay layers using Web Components. With Web Components we can isolate each overlay from the outside world, so that the CSS style of the elements inside the overlay component is not affected by style changes originated from outside the overlay. Such feature can dramatically reduce the amount of time consumed by style recalculations when the map shifts locations.  Another improvement is integrating VIZIC with other interactive plotting libraries and making it even easier for astronomers to explore the catalogs by taking advantage of the scripting power of Python, in a way that multiple tools are connected and the change in one is reflected in the other one, providing a complete user analysis experience in a Jupyter notebook.">
</outline>
<outline text="Acknowledgements" _note="RJB acknowledges support from the National Science Foundation Grant No. AST-1313415.  Some of the results in this paper have been derived using the HEALPix package.  Funding for the Sloan Digital Sky Survey IV has been provided by the Alfred P. Sloan Foundation, the U.S. Department of Energy Office of Science, and the Participating Institutions. SDSS-IV acknowledges support and resources from the Center for High-Performance Computing at the University of Utah. The SDSS web site is www.sdss.org.  SDSS-IV is managed by the Astrophysical Research Consortium for the Participating Institutions of the SDSS Collaboration including the Brazilian Participation Group, the Carnegie Institution for Science, Carnegie Mellon University, the Chilean Participation Group, the French Participation Group, Harvard-Smithsonian Center for Astrophysics, Instituto de Astrofísica de Canarias, The Johns Hopkins University, Kavli Institute for the Physics and Mathematics of the Universe (IPMU) / University of Tokyo, Lawrence Berkeley National Laboratory, Leibniz Institut für Astrophysik Potsdam (AIP), Max-Planck-Institut für Astronomie (MPIA Heidelberg), Max-Planck-Institut für Astrophysik (MPA Garching), Max-Planck-Institut für Extraterrestrische Physik (MPE), National Astronomical Observatories of China, New Mexico State University, New York University, University of Notre Dame, Observatário Nacional / MCTI, The Ohio State University, Pennsylvania State University, Shanghai Astronomical Observatory, United Kingdom Participation Group, Universidad Nacional Autónoma de México, University of Arizona, University of Colorado Boulder, University of Oxford, University of Portsmouth, University of Utah, University of Virginia, University of Washington, University of Wisconsin, Vanderbilt University, and Yale University.">
</outline>
  </body>
</opml>