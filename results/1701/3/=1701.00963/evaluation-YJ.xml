<?xml version="1.0" encoding="UTF-8"?>
<opml version="2.0">
  <head>
    <title></title>
    <abstract> </abstract>
  </head>
  <body>
<outline text="Implementation and Evaluation" _note="In the previous sections, we presented the RADIUS system design and analyzed the impact of its parameters on the detection performance. Based on these, we implemented the DA component of RADIUS for TelosB sensor platforms and the VCC for standard PCs. In this section, we detail our implementation and discuss the system overhead. At last, we show the evaluation results on the detection performance of the overall implemented system in an indoor testbed.">
  <outline text="System Implementation" _note="In this section, we first describe the implementation details of the two major RADIUS components: the DA and the VCC. We introduce the programming interface of the DA to show that it is easy to use for higher-layer services and applications, followed by the implementation details of the VCC and of the RADIUS IoT extension.  ``` {frame=&quot;single&quot;}   % Start your code-block          interface DetectionAgent {     command void configureDA(Struct_Param parameters);     command error_t start_Training();     command error_t stop_Training();     command error_t start_Detection();     command error_t stop_Detection();     command void update_RSSI(uint8_t rssi, uint8_t childId);     }      ```  To ease the integration of RADIUS into higher-layer applications, we implemented the DA component as a module on TinyOS 2.1.2, which provides an interface `DetectionAgent` (see Figure  ). The `configureDA` command is used to configure DA with user-specified parameter settings (e.g., the initial ) as provided in configuration messages sent by the VCC. The interface also provides control commands such as `start_Training` or `start_Detection` for executing the different phases in RADIUS. The command `update_RSSI` is used to update the RSSI distribution of each link during both the training and the detection phases. With this programming interface, an application only needs to react to VCC’s control messages and call the different commands accordingly. Note that RADIUS is not restricted to TelosB or TinyOS and can be easily adapted to other embedded devices with low-power radios.  The component VCC, running on a standard PC, is implemented in Java. It processes the alarms received from the network and produces diagnosis results reporting the relevant anomalies and their locations for the nodes that are experiencing high packet losses, which assists the system operator in identifying possible remedy actions. The VCC also includes a MONITORING USER INTERFACE (see Figure  ), which provides a visualization of the packet delivery performance, detection status and the diagnosis results. Via this interface, the operator can monitor and control the RADIUS system.  We have also extended the VCC with an Internet-of-Things interface, which allows the VCC to connect with openHAB , an open source smart home automation software. MQTT , a lightweight messaging transport protocol, is used for the communication between openHAB and the VCC. With this extension, the user can remotely control the RADIUS system and monitor the detection results with an Android smart phone, as depicted in Figure  .  The current implementation of RADIUS is able to detect anomalies in link quality. Nevertheless, the programming interface (Figure  ) and the DA module can be easily extended to detect anomalies of other attributes, e.g., CRC error rate or packet overflow rate. In addition, RADIUS currently works for static tree-based data collection applications but it can be also applied to other routing schemes.">
  </outline>
  <outline text="System Overheads" _note="In this section, we analyze the memory, communication and computation overheads of our RADIUS implementation.">
    <outline text="Memory overhead." _note="Detection Agents incur memory overhead on RAM (data) and ROM (program) of sensor nodes. As presented in Section  , we keep updating the training set to adapt the mean and standard deviation of the density distribution of RSSI. To avoid increasing RAM usage during the update, we implemented this in a memory-friendly way, i.e., to compute and with a single pass without storing the previous measurements of RSSI. To do so, we reformulate and in the following way: where and are defined as follows: in which is the i-th RSSI reading. Instead of storing the entire training set, the DA then stores only 2 counters ( and ) for each link to compute and update and . By doing so, the RAM consumption of RADIUS has a complexity of , where is the number of links from direct child nodes and is the number of monitored attributes (e.g., RSSI, CRC error rate), remaining independent from the sample number.  To evaluate the RAM and ROM overhead, we compare the memory usage of a tree-based data collection application with and without the DA module. In the application, each node has two one-hop child nodes and therefore stores information about two links. The application alone consumes 3060 bytes in RAM and 25082 bytes in ROM while the application including the DA module consumes 3176 bytes in RAM and 31170 bytes in ROM. This indicates that the DA module consumes 116 bytes RAM (in comparison to 10 KB RAM in a TelosB device), and approximately 6 KB ROM (in comparison to 48 KB ROM in a TelosB device).">
    </outline>
    <outline text="Communication overhead." _note="Due to its distributed architecture, the anomaly detection process alone incurs no communication overhead in RADIUS. It requires additional communication only if the DAs send alarms corresponding to detected anomalies, or when the VCC sends control messages. To reduce such overhead, the alarms with minimum information (2 bytes) about the detected anomaly are piggybacked on the application packets. On the other hand, the number of control messages delivered from the VCC to the DAs, based on our indoor testbed evaluation results, is negligible compared to the amount of received application packets.">
    </outline>
    <outline text="Computation overhead." _note="The main computation overhead comes from the processing of the Bayesian thresholding. In RADIUS, the complexity of Bayesian thresholding involves the calculation of the mean, the standard deviation and the Bayes threshold according to Equation  . Testing results show that the processing of a Bayes threshold takes about 10 ms, which is small compared to the normal packet inter-arrival time in typical data collection applications.  ">
    </outline>
  </outline>
  <outline text="Experimental Evaluation" _note="We have evaluated the detection performance of our RADIUS implementation in an indoor testbed (Figure  ) consisting of 12 TelosB motes, deployed in several offices of a university building. Each sensor node runs an application that collects environmental data and sends it to the sink every 2 seconds following a tree-based routing topology. We instrumented a Detection Agent on each sensor node and ran the VCC on a PC connected to the sink node (Base Station).  To configure the RADIUS system, we adopt the system parameter settings suggested in the previous analysis (Section  ). Table   summarizes the suggested parameter settings. After a training period of about 5 minutes, RADIUS starts the detection phase for a period of about 24 hours. During the experiment, we logged the received alarms, the RSSI traces and the PDR traces. Figure   demonstrates our results of detecting link quality anomalies on one of the links.  [0.95]{}[|l|l|l|]{} **Techniques** &amp; **Parameters** &amp; **Settings**\ **Bayesian** &amp; initial &amp; 0.8\ **Thresholding** &amp; maximum &amp; 0.99\ **Training Set Size** &amp; sample number to compute &amp; 250\ **Estimation** &amp; max. estimated error of mean &amp; 1 dBm\ **Data Smoothing** &amp; sliding window size &amp; 3\ **Training Set Update** &amp; update window size &amp; 50\ **A PRIORI Probability** &amp; max. alarm number &amp; 5\ **Refinement** &amp; adjustment step &amp; 0.003\     From the PDR trace depicted in Figure  (b), we can observe that the link frequently experienced high packet losses during the first 4 hours and the last 3 hours due to the bad channel quality caused by the students’ movements crossing the communication link (see Figure  (a)). The received alarms that reported such anomalous link quality degradation are marked in red in Figure  (d). The results show a good detection accuracy. The overall FNR and FPR of detecting the anomalous RSSI degradation for this link over 24 hours are 5.1% and 4%, respectively.  In addition, we can see from Figure  (e) that RADIUS can keep the error rate stable over the detection period. Figure  (c) clearly shows that the threshold is adaptive to RSSI variations due to the environment changes. From our analysis based on the logged refinement points (marked in Figure  (d)), RADIUS refines the A PRIORI probability at around 13:00 on the first day and 10:00 on the next day to reduce FPR and thus maintain the detection accuracy.  To demonstrate that RADIUS can robustly achieve high detection accuracy for all the links across the entire deployed network, we plot in Figure   the error rate for every link in the testbed. The figure shows that with a set of global parameter settings (listed in Table  ), RADIUS achieves a low error rate for every link in the network (6.13% on average).  ">
  </outline>
</outline>
  </body>
</opml>