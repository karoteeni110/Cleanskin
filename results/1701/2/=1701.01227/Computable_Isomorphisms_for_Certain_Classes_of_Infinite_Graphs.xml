<?xml version="1.0" encoding="UTF-8"?>
<opml version="2.0">
  <head>
    <title>**Computable Isomorphisms for Certain Classes of Infinite Graphs**</title>
    <abstract>We investigate (2,1):1 structures, which consist of a countable set
together with a function such that for every element in , maps either
exactly one element or exactly two elements of to . These structures
extend the notions of injection structures, 2:1 structures, and (2,0):1
structures studied by Cenzer, Harizanov, and Remmel, all of which can be
thought of as infinite directed graphs. We look at various
computability-theoretic properties of (2,1):1 structures, most notably
that of computable categoricity. We say that a structure is computably
categorical if there exists a computable isomorphism between any two
computable copies of . We give a sufficient condition under which a
(2,1):1 structure is computably categorical, and present some examples
of (2,1):1 structures with different computability-theoretic properties. </abstract>
  </head>
  <body>
<outline text="Introduction" _note="In computable model theory, we study the properties of classical&#10;mathematical structures from the perspective of computability theory. A&#10;set is COMPUTABLE if there is a Turing program, or more generally, an&#10;algorithm, that can decide the membership of . Furthermore, a set is&#10;COMPUTABLY ENUMERABLE if there is an algorithm to enumerate the elements&#10;of . A countable structure over a finite language is COMPUTABLE if its&#10;domain is computable and all of its functions and relations are&#10;computable. Unless otherwise specified, all of our structures are&#10;computable, and we assume that their domain is , the set of natural&#10;numbers.&#10;&#10;One of the key concepts in computable model theory is that of computable&#10;isomorphisms between structures. We say that two computable structures&#10;and that are isomorphic to each other are COMPUTABLY ISOMORPHIC if there&#10;exists a computable function , where is an isomorphism from to .&#10;Computable isomorphisms preserve not only the functions and relations of&#10;a structure, but also the algorithmic properties of the structure. It is&#10;very possible for two isomorphic computable structures to not be&#10;COMPUTABLY isomorphic. Thus, we have the following definition.\&#10;&#10;A computable structure is COMPUTABLY CATEGORICAL if every two computable&#10;isomorphic copies of are computably isomorphic.&#10;&#10;We seek to classify computable structures up to computable isomorphism.&#10;That is, within a class of structures, we wish to provide&#10;characterizations of those computable structures that are computably&#10;categorical. This has been done for various classes of mathematical&#10;structures. For example, Goncharov and Dzgoev , and independently Remmel&#10;, proved that a computable linear order is computably categorical if and&#10;only if it has only finitely many successor pairs. Additionally,&#10;Goncharov and Dzgoev , LaRoche , and Remmel independently proved that a&#10;computable Boolean algebra is computably categorical if and only if it&#10;has only finitely many atoms. Goncharov, Lempp, and Solomon&#10;characterized computably categorical ordered abelian groups as those&#10;with finite rank. In , Calvert, Cenzer, Harizanov, and Morozov gave a&#10;characterization of computably categorical equivalence structures&#10;(structures consisting of a countable set and an equivalence relation).&#10;&#10;Computable categoricity has also been extensively studied for certain&#10;types of graphs. Lempp, McCoy, Miller, and Solomon characterized&#10;computable trees of finite height that are computably categorical, and&#10;Miller previously showed that no computable tree of infinite height is&#10;computably categorical. In , Csima, Khoussainov, and Liu investigated&#10;computable categoricity of STRONGLY LOCALLY FINITE GRAPHS, those which&#10;have countably many finite connected components, by looking at proper&#10;embeddability of the components. As an example, it can be shown that the&#10;first graph in Figure 1 is computably categorical, whereas the second&#10;graph is not.&#10;&#10;(A”) at (0,0.7) \[label=above: 0\]; (B”) at (0.5,0.7) \[label=above:&#10;1\]; (C”) at (1,0.7) \[label=above: 2\]; (D”) at (1.5,0.7)&#10;\[label=above: 3\]; (E”) at (2,0.7) \[label=above: 4\]; (F”) at&#10;(2.5,0.7) \[label=above: 5\]; (G”) at (3,0.7) \[label=above: 6\]; (H”)&#10;at (3.5,0.7) \[label=above: 7\]; (I”) at (4,0.7) \[label=above: 8\];&#10;(J”) at (4.5,0.7) \[label=above: 9\]; (K”) at (5,0.7) \[label=above:&#10;10\]; (L”) at (5.5,0.7) \[label=above: 11\]; (M”) at (6,0.7)&#10;\[label=above: 12\]; (N”) at (6.5,0.7) \[label=above: 13\]; (O”) at&#10;(7,0.7) \[label=above: 14\]; (P”) at (7.5,0.7) \[label=above: 15\]; at&#10;(8,0.7) []{}; at (-3.33,0.7) ;&#10;&#10;(A”) to (B”); (C”) to (D”); (E”) to (F”); (G”) to (H”); (I”) to (J”);&#10;(K”) to (L”); (M”) to (N”); (O”) to (P”);&#10;&#10;(A’) at (0,0) \[label=above: 0\]; (B’) at (0.5,0) \[label=above: 1\];&#10;(C’) at (1,0) \[label=above: 2\]; (D’) at (1.5,0) \[label=above: 3\];&#10;(E’) at (2,0) \[label=above: 4\]; (F’) at (2.5,0) \[label=above: 5\];&#10;(G’) at (3,0) \[label=above: 6\]; (H’) at (3.5,0) \[label=above: 7\];&#10;(I’) at (4,0) \[label=above: 8\]; (J’) at (4.5,0) \[label=above: 9\];&#10;(K’) at (5,0) \[label=above: 10\]; (L’) at (5.5,0) \[label=above: 11\];&#10;(M’) at (6,0) \[label=above: 12\]; (N’) at (6.5,0) \[label=above: 13\];&#10;(O’) at (7,0) \[label=above: 14\]; (P’) at (7.5,0) \[label=above: 15\];&#10;at (8,0) []{}; at (-3,0) ;&#10;&#10;(B’) to (C’); (D’) to (E’); (E’) to (F’); (G’) to (H’); (H’) to (I’);&#10;(I’) to (J’); (K’) to (L’); (L’) to (M’); (M’) to (N’); (N’) to (O’);&#10;&#10;We are interested in classes of infinite directed graphs that are&#10;derived from computable functions. Cenzer, Harizanov, and Remmel first&#10;studied directed graphs of this type in , where they defined injection&#10;structures. An INJECTION STRUCTURE is a countable set together with an&#10;injective function . An injection structure can be completely classified&#10;up to isomorphism by the number, type, and size of its ORBITS, which are&#10;the types of connected components the structure may have.&#10;&#10;\(A) at (-1.5,1) \[label=above: \]; (B) at (-0.5,1) \[label=above: \];&#10;(C) at (0.5,1) \[label=above: \]; (D) at (1.5,1) \[label=above: \]; at&#10;(2.3,1) []{}; at (-5,1) ;&#10;&#10;\(A) to (B); (B) to (C); (C) to (D); (D) to (2,1);&#10;&#10;(A’) at (-2,0) \[label=above: \]; (B’) at (-1,0) \[label=above: \]; (C’)&#10;at (0,0) \[label=above: \]; (D’) at (1,0) \[label=above: \]; (E’) at&#10;(2,0) \[label=above: \]; at (2.8,0) []{}; at (-2.8,0) []{}; at (-5,0) ;&#10;&#10;(A’) to (B’); (B’) to (C’); (C’) to (D’); (D’) to (E’); (E’) to (2.5,0);&#10;(-2.5,0) to (A’);&#10;&#10;(A”) at (-1,-1) \[label=below: \]; (B”) at (0,-1) \[label=below: \];&#10;(C”) at (1,-1) \[label=below: \]; at (-5,-1) ;&#10;&#10;(A”) to (B”); (B”) to (C”); (C”) to \[bend right=40\] (A”);&#10;&#10;Cenzer, Harizanov, and Remmel obtained the following characterization&#10;theorem for injection structures.&#10;&#10;A computable injection structure is computably categorical if and only&#10;if has only finitely many infinite orbits, that is, only finitely many&#10;-orbits and only finitely many -orbits.&#10;&#10;Next, Cenzer, Harizanov, and Remmel looked at TWO-TO-ONE (2:1)&#10;STRUCTURES , where for all , as well as (2,0):1 STRUCTURES , where for&#10;all . Here, denotes the cardinality of the set . Thus, in a 2:1&#10;structure, every element has exactly two pre-images under , and in a&#10;(2,0):1 structure, every element has either exactly two pre-images or no&#10;pre-image under . The types of orbits for these structures are shown&#10;below.&#10;&#10;at (3.7,2.5) [\*]{}; (A) at (0,0.5) ; (B) at (0.5,0); (C) at (0,-0.5) ;&#10;(D) at (-0.5,0) ; (A1) at (0,1); (B1) at (1,0); (C1) at (0, -1); (D1) at&#10;(-1,0); at (0, 1.5); at (1.5, 0); at (0, -1.5); at (-1.5, 0); at (0,2) ;&#10;&#10;\(A) to \[bend left=45\] (B); (B) to \[bend left=45\] (C); (C) to \[bend&#10;left=45\] (D); (D) to \[bend left=45\] (A);&#10;&#10;(A1) to (A); (-0.5, 1.75) to (A1); (0.5,1.75) to (A1); (-0.5,1.75) to&#10;(0.5,1.75);&#10;&#10;(B1) to (B); (1.75, -0.5) to (B1); (1.75, 0.5) to (B1); (1.75, 0.5) to&#10;(1.75, -0.5);&#10;&#10;(C1) to (C); (-0.5,-1.75) to (C1); (0.5,-1.75) to (C1); (-0.5,-1.75) to&#10;(0.5,-1.75);&#10;&#10;(D1) to (D); (-1.75, -0.5) to (D1); (-1.75,0.5) to (D1); (-1.75,-0.5) to&#10;(-1.75,0.5);&#10;&#10;\(E) at (4,1); (F) at (5.5,1); (G) at (7,1); at (7.8,1)[]{}; at (3.2,1)&#10;[]{}; (E1) at (4,0.5); (F1) at (5.5,0.5); (G1) at (7,0.5); at (4, 0); at&#10;(5.5, 0); at (7, 0); at (5.5,2) ;&#10;&#10;\(E) to (F); (F) to (G); (E1) to (E); (F1) to (F); (G1) to (G); (G) to&#10;(7.5,1); (3.5,1) to (E); (3.5,-.25) to (E1); (4.5,-.25) to (E1);&#10;(3.5,-.25) to (4.5,-.25);&#10;&#10;(5,-.25) to (F1); (6,-.25) to (F1); (5,-.25) to (6,-.25);&#10;&#10;(6.5,-.25) to (G1); (7.5,-.25) to (G1); (6.5,-.25) to (7.5,-.25);&#10;&#10;at (5.78,-1) ; at (4.23, -1.5) ;&#10;&#10;at (3.7,2.5) [\*]{}; (A) at (0,0.5) ; (B) at (0.5,0); (C) at (0,-0.5) ;&#10;(D) at (-0.5,0) ; (A1) at (0,1); (B1) at (1,0); (C1) at (0, -1); (D1) at&#10;(-1,0); at (0, 1.5); at (1.5, 0); at (0, -1.5); at (-1.5, 0); at (0,2) ;&#10;&#10;\(A) to \[bend left=45\] (B); (B) to \[bend left=45\] (C); (C) to \[bend&#10;left=45\] (D); (D) to \[bend left=45\] (A);&#10;&#10;(A1) to (A); (-0.5, 1.75) to (A1); (0.5,1.75) to (A1); (-0.5,1.75) to&#10;(0.5,1.75);&#10;&#10;(B1) to (B); (1.75, -0.5) to (B1); (1.75, 0.5) to (B1); (1.75, 0.5) to&#10;(1.75, -0.5);&#10;&#10;(C1) to (C); (-0.5,-1.75) to (C1); (0.5,-1.75) to (C1); (-0.5,-1.75) to&#10;(0.5,-1.75);&#10;&#10;(D1) to (D); (-1.75, -0.5) to (D1); (-1.75,0.5) to (D1); (-1.75,-0.5) to&#10;(-1.75,0.5);&#10;&#10;\(E) at (4,1.75); (F) at (5.5,1.75); (G) at (7,1.75); at (7.8,1.75)[]{};&#10;at (3.2,1.75) []{}; (E1) at (4,1.25); (F1) at (5.5,1.25); (G1) at&#10;(7,1.25); at (4.05, 0.70); at (5.5, 0.75); at (7, 0.75); at (5.5,2) ;&#10;&#10;\(E) to (F); (F) to (G); (E1) to (E); (F1) to (F); (G1) to (G); (G) to&#10;(7.5,1.75); (3.5,1.75) to (E); (3.5,0.5) to (E1); (4.5,0.5) to (E1);&#10;(3.5,0.5) to (4.5,0.5);&#10;&#10;(5,0.5) to (F1); (6,0.5) to (F1); (5,0.5) to (6,0.5);&#10;&#10;(6.5,0.5) to (G1); (7.5,0.5) to (G1); (6.5,0.5) to (7.5,0.5);&#10;&#10;\(H) at (4,-0.25); (I) at (5.5,-0.25); (J) at (7,-0.25); at&#10;(7.8,-0.25)[]{}; at (3.2,-0.25) ; (H1) at (4,-0.75); (I1) at&#10;(5.5,-0.75); (J1) at (7,-0.75); at (4, -1.25); at (5.5, -1.25); at (7,&#10;-1.25); at (5.5,0);&#10;&#10;\(H) to (I); (I) to (J); (H1) to (H); (I1) to (I); (J1) to (J); (J) to&#10;(7.5,-0.25); (3.2,-0.25) to (H);&#10;&#10;(3.5,-1.5) to (H1); (4.5,-1.5) to (H1); (3.5,-1.5) to (4.5,-1.5);&#10;&#10;(5,-1.5) to (I1); (6,-1.5) to (I1); (5,-1.5) to (6,-1.5);&#10;&#10;(6.5,-1.5) to (J1); (7.5,-1.5) to (J1); (6.5,-1.5) to (7.5,-1.5);&#10;&#10;at (3.5, -2.08);&#10;&#10;Cenzer, Harizanov, and Remmel investigated computably categorical&#10;(2,0):1 structures by considering additional structural and algorithmic&#10;properties. They also characterized the computably categorical 2:1&#10;structures by proving the following theorem.\&#10;&#10;A computable 2:1 structure is computably categorical if and only if has&#10;only finitely many -chains.&#10;&#10;In this paper, we define a (2,1):1 structure, which is a natural&#10;extension of the structures introduced by Cenzer, Harizanov, and Remmel.&#10;Our ultimate goal is to provide a characterization of computable&#10;categoricity for these directed graphs, as has been done for the graphs&#10;discussed above. In Section 2, we establish fundamental structural and&#10;computability-theoretic properties of (2,1):1 structures, and use these&#10;to investigate computable categoricity for such structures. In section&#10;3, we present some examples of (2,1):1 structures with certain desired&#10;computability-theoretic properties.">
</outline>
<outline text="Computable Categoricity of (2,1):1 Structures" _note="We begin this section by defining a (2,1):1 structure.&#10;&#10;A (2,1):1 STRUCTURE is a set together with a function such that for all&#10;. That is, every element in has either exactly two pre-images or exactly&#10;one pre-image under .&#10;&#10;Naturally, we say that a (2,1):1 structure is COMPUTABLE if is a&#10;computable set and is a computable function. From now on, we will assume&#10;that all of our (2,1):1 structures are computable, with , unless&#10;otherwise stated.&#10;&#10;Although we have mentioned the concept in the introduction, we must now&#10;formally define the ORBIT OF AN ELEMENT in a (2,1):1 structure.&#10;&#10;Let be a (2,1):1 structure, and let .The ORBIT OF IN , denoted by , is&#10;defined as follows:\&#10;&#10;Here, denotes the result of iterating the function M times on . If we&#10;think of (2,1):1 structures as directed graphs, we can think of orbits&#10;as the connected components of the graph.&#10;&#10;It is not hard to see that a (2,1):1 structure can only consist of two&#10;general types of orbits. We refer to them as **K-cycles** and&#10;**-chains**, following the naming conventions for the orbits of 2:1&#10;structures used by Cenzer, Harizanov, and Remmel. We describe these&#10;orbits below.\&#10;[**K-Cycles**]{}&#10;&#10;A **K-cycle** is a directed cycle with elements, where every element in&#10;the cycle has a directed binary tree attached, each of which is either&#10;infinite or empty.&#10;&#10;\(A) at (0,1) \[label=below:\]; (B) at (1,0) \[label = left:\] ; (C) at&#10;(0,-1) \[label=above:\]; (D) at (-1,0) \[label = right:\];&#10;&#10;(A1) at (0,1.5); (A2) at (0,2); (A3) at (0,2.5); (A4) at (0,3); (A5) at&#10;(0,3.5)[]{};&#10;&#10;(B1) at (1.5,0); (B21) at (2,-1); (B22) at (2, 1); (B31) at (2.5,-1.5);&#10;(B32) at (2.5, -0.5); (B33) at (2.5, 0.5); (B34) at (2.5, 1.5); (B41) at&#10;(3.5, -1.75); (B42) at (3.5, -1.25); (B43) at (3.5, -0.75); (B44) at&#10;(3.5, -0.25); (B45) at (3.5, 0.25); (B46) at (3.5, 0.75); (B47) at (3.5,&#10;1.25); (B48) at (3.5, 1.75); (B5) at (4,0)[]{};&#10;&#10;(D1) at (-1.5,0); (D21) at (-2, 1); (D22) at (-2, -1); (D31) at (-2.5,&#10;1); (D32) at (-2.5, -0.5); (D33) at (-2.5, -1.5); (D41) at (-3.5, 1.25);&#10;(D42) at (-3.5, 0.75); (D43) at (-3.5, -0.5); (D44) at (-3.5, -1.25);&#10;(D45) at (-3.5, -1.75); (D5) at (-4,0)[]{};&#10;&#10;\(A) to \[bend left=45\] (B); (B) to \[bend left=45\] (C); (C) to \[bend&#10;left=45\] (D); (D) to \[bend left=45\] (A);&#10;&#10;(A1) to (A); (A2) to (A1); (A3) to (A2); (A4) to (A3);&#10;&#10;(B1) to (B); (B21) to (B1); (B22) to (B1); (B31) to (B21); (B32) to&#10;(B21); (B33) to (B22); (B34) to (B22); (B41) to (B31); (B42) to (B31);&#10;(B43) to (B32); (B44) to (B32); (B45) to (B33); (B46) to (B33); (B47) to&#10;(B34); (B48) to (B34);&#10;&#10;(D1) to (D); (D21) to (D1); (D22) to (D1); (D31) to (D21); (D32) to&#10;(D22); (D33) to (D22); (D41) to (D31); (D42) to (D31); (D43) to (D32);&#10;(D44) to (D33); (D45) to (D33);&#10;&#10;An element of a K-cycle is called a **cyclic element** if there exists&#10;an such that . We denote the cyclic elements of a K-cycle by , ,...,,&#10;where for , and for , and . Since each K-cycle consists of only one&#10;directed cycle, we can uniquely specify a particular K-cycle within a&#10;(2,1):1 structure by listing its K cyclic elements.&#10;&#10;In Figure 4, each of the cyclic elements , , , has a different type of&#10;binary tree attached. The tree attached to is often referred to as a&#10;**degenerate tree**, where every element in the tree has exactly one&#10;pre-image. The tree attached to is a **full binary tree**, as every&#10;element has exactly two pre-images. The tree attached to is the **empty&#10;tree**, and the tree attached to is an arbitrary infinite binary tree&#10;that is neither empty, degenerate, nor full.\&#10;[**-Chains**]{}&#10;&#10;A **-chain** consists of a -orbit of elements, where every element in&#10;the orbit has a directed binary tree attached, each of which is either&#10;infinite or empty.&#10;&#10;\(A) at (1,0)\[label=above left:\]; (B) at (2,0)\[label=above:\]; (C) at&#10;(4,0)\[label=above:\]; (D) at (6,0)\[label=above:\]; (E) at&#10;(8,0)\[label=above:\]; (F) at (10,0)\[label=above:\]; (G) at&#10;(11,0)\[label=above right:\]; (X) at (0.5,0)[]{}; (Y) at (11.5,0)[]{};&#10;&#10;(B1) at (2,-1); (B2) at (2,-2); (B3) at (2,-3); (B4) at (2,-4); (B5) at&#10;(2,-4.5)[]{};&#10;&#10;(D1) at (6,-1); (D21) at (5, -2); (D22) at (7, -2); (D31) at (4.5, -3);&#10;(D32) at (5.5, -3); (D33) at (6.5, -3); (D34) at (7.5, -3); (D41) at&#10;(4.25,-4); (D42) at (4.75,-4); (D43) at (5.25,-4); (D44) at (5.75,-4);&#10;(D45) at (6.25,-4); (D46) at (6.75,-4); (D47) at (7.25,-4); (D48) at&#10;(7.75,-4); (D5) at (6, -4.5)[]{};&#10;&#10;(F1) at (10,-1); (F21) at (9,-2); (F22) at (11,-2); (F31) at (8.5, -3);&#10;(F32) at (9.5,-3); (F33) at (11,-3); (F41) at (8.5,-4); (F42) at&#10;(9.25,-4); (F43) at (9.75,-4); (F44) at (11,-4); (F5) at (10,-4.5)[]{};&#10;&#10;\(A) to (B); (B) to (C); (C) to (D); (D) to (E); (E) to (F); (F) to (G);&#10;&#10;(B1) to (B); (B2) to (B1); (B3) to (B2); (B4) to (B3);&#10;&#10;(D1) to (D); (D21) to (D1); (D22) to (D1); (D31) to (D21); (D32) to&#10;(D21); (D33) to (D22); (D34) to (D22); (D41) to (D31); (D42) to (D31);&#10;(D43) to (D32); (D44) to (D32); (D45) to (D33); (D46) to (D33); (D47) to&#10;(D34); (D48) to (D34);&#10;&#10;(F1) to (F); (F21) to (F1); (F22) to (F1); (F31) to (F21); (F32) to&#10;(F21); (F33) to (F22); (F41) to (F31); (F42) to (F32); (F43) to (F32);&#10;(F44) to (F33);&#10;&#10;Here, a -orbit refers to an infinite set of elements such that for all&#10;with , . Unlike with cyclic elements in a K-cycle, a -orbit within a&#10;-chain does not necessarily UNIQUELY determine the -chain, since a&#10;-chain may contain more than one different -orbit. Indeed, if a -chain&#10;contains any element with two pre-images, then that -chain will contain&#10;more than one distinct -orbit. However, given a -chain, we can establish&#10;a **canonical -orbit** , where is the least element in the -chain (under&#10;the usual ordering on ), and is the least pre-image of for all . Thus,&#10;in Figure 5, if we take the labeled elements to be the canonical -orbit&#10;of the -chain, then is the least pre-image of , is the least pre-image&#10;of , and so on.&#10;&#10;As we can see from Figures 4 and 5, the orbits of a (2,1):1 structure&#10;are essentially directed graphs. However, this is not quite correct, as&#10;the orbit of an element is only defined to be the SET of elements in the&#10;same connected component as , and does not include any additional&#10;structure specifying an edge relation. It is advantageous to be able to&#10;refer to a connected component in a (2,1):1 structure as a directed&#10;graph instead of just a set of vertices. So we formalize this notion in&#10;the following definition.&#10;&#10;Let be a (2,1):1 structure, and let . The CONNECTED COMPONENT OF IN ,&#10;denoted by , is the directed graph associated with . That is:&#10;&#10;where and .&#10;&#10;To further analyze our structures as graphs, we explore another&#10;fundamental property: the TREE OF AN ELEMENT.&#10;&#10;Let be a (2,1):1 structure, and let . The TREE OF IN , denoted by , is&#10;defined as:&#10;&#10;Furthermore, the TREE OF IN , denoted by , is the directed graph&#10;associated with . That is:&#10;&#10;where and .&#10;&#10;Intuitively, we can think of as the set of all PREDECESSORS of (or the&#10;set of all elements that will eventually LEAD to ), and we can think of&#10;as a rooted binary tree with as its root. It is apparent that if is a&#10;cyclic element, then , which is the entire K-cycle containing . However,&#10;we often wish to refer to those elements in a K-cycle that are connected&#10;to a cyclic element via a directed path that does not contain other&#10;cyclic elements. So we introduce the notion of an EXCLUSIVE TREE.&#10;&#10;Let be a (2,1):1 structure, and let be a cyclic element on a K-cycle in&#10;. The EXCLUSIVE TREE OF IN , denoted by , is the following set:&#10;&#10;The EXCLUSIVE TREE OF IN , denoted by is the directed graph associated&#10;with .&#10;&#10;The following properties of (2,1):1 structures will also be useful&#10;later.\&#10;&#10;Let be a (2,1):1 structure, , and .&#10;&#10;The NTH LEVEL OF THE TREE OF , denoted by , is defined as:&#10;&#10;Similarly, the NTH LEVEL OF THE EXCLUSIVE TREE OF is defined as:&#10;&#10;The TREE OF TRUNCATED AT LEVEL N, denoted by , is defined as:&#10;&#10;Similarly, the EXCLUSIVE TREE OF TRUNCATED AT LEVEL N is defined as:&#10;&#10;Naturally, and are the associated directed graphs for the sets described&#10;in Definition 2.6(b).&#10;&#10;Finally, we introduce two special functions for (2,1):1 structures, the&#10;BRANCHING FUNCTION and the BRANCH ISOMORPHISM FUNCTION, which will allow&#10;us to further study the computable categoricity of our graphs.&#10;&#10;Let be a (2,1):1 structure. The BRANCHING FUNCTION OF , denoted by , is&#10;defined as:&#10;&#10; The HAIR SET OF , denoted by , is defined as:&#10;&#10;[]{}&#10;&#10;The SPLIT HAIR SET OF , denoted by , is defined as:&#10;&#10;Let be a (2,1):1 structure, and let have distinct pre-images and . The&#10;BRANCH ISOMORPHISM FUNCTION OF , denoted by , is defined as:&#10;&#10;Essentially, the branching function takes an element as an input, and&#10;outputs the number of immediate predecessors of . The branch isomorphism&#10;function takes an element with two distinct pre-images as an input, and&#10;tells us if the TREES of those pre-images are isomorphic to each other.&#10;Note that if is a cyclic element, then . This is because one predecessor&#10;of will be another cyclic element while the other predecessor will be a&#10;non-cyclic element , so will be the entire K-cycle containing , while&#10;will be an infinite binary tree with no cycles. Hence, is clearly not&#10;isomorphic to .&#10;&#10;It is also important to note that neither nor is necessarily a&#10;computable function, even if the underlying (2,1):1 structure is&#10;computable. (In Section 3, we will construct an example of such a&#10;structure.) Also, while the domain of is always computable, the domain&#10;of may not be computable. In fact, if is not computable, then neither is&#10;the domain of . We generally avoid this issue by assuming that the&#10;branching function is computable. However, computability of the&#10;branching function does not guarantee computability of the branch&#10;isomorphism function, as we will see in Section 3.&#10;&#10;We will now establish our first result regarding computable isomorphisms&#10;between (2,1):1 structures.&#10;&#10;Let and be two computable isomorphic (2,1):1 structures, both with a&#10;computable branching function and a computable branch isomorphism&#10;function. If and are non-cyclic elements such that , then the two Trees&#10;are computably isomorphic. Likewise, if and are cyclic elements such&#10;that , then the two exclusive Trees are computably isomorphic.&#10;&#10;We construct a computable isomorphism from to in stages as follows.\&#10;STAGE 0: Define .&#10;&#10;STAGE S+1: Suppose that from stage we have , an isomorphism from to .&#10;For all elements , define . Let and let . If , find the unique pre-image&#10;of under , call it , and find the pre-image of under , call it . Then&#10;define .&#10;&#10;If , find both pre-images of under , call them and , and then find both&#10;pre-images of under , call them and . If , then define and , where and&#10;are defined under the usual ordering on . If , then there exists a level&#10;such that . In that case, use to reveal the vertices and edges of and&#10;one level at a time until we find such a level . Then, use to reveal the&#10;vertices and edges of and . If , then define and . Otherwise, define and&#10;.&#10;&#10;Repeat the procedure above for all , so is defined on all elements in .&#10;This completes the construction. Let .&#10;&#10;We must now verify that is a computable isomorphism from to .\&#10;**Claim 1**. The function is an isomorphism from to .\&#10;PROOF OF CLAIM 1. Suppose is an isomorphism from to such that there&#10;exists an isomorphism from to with . Let and let .&#10;&#10;If , then it must be the case that as well. This means that and each&#10;have a unique pre-image, and respectively, and so we can properly extend&#10;to by defining . Furthermore, any isomorphism from to that extends must&#10;map to . Thus, there certainly exists an isomorphism from to that&#10;extends and agrees with on .&#10;&#10;If , then again, it must be the case that . So let and be the distinct&#10;pre-images of under , and let and be the distinct pre-images of under .&#10;If , then it must be the case that . Moreover, the TREES of both and are&#10;isomorphic to the TREES of both and . So regardless of where maps and ,&#10;there will exist an isomorphism from to that extends and agrees with on&#10;both and . If , then it must be the case that as well. It follows from&#10;the construction that if maps to , then , and thus it must be that . The&#10;reverse statement also holds if maps to . Since the branches of (and the&#10;branches of ) are not isomorphic to each other, any isomorphism from to&#10;extending must agree with on and .&#10;&#10;Thus, it is apparent that , once defined on all elements in , is an&#10;isomorphism from to . Furthermore, there must exist an isomorphism from&#10;to that extends , as the branching functions and the branch isomorphism&#10;functions prevent us from “making a mistake&quot; throughout the&#10;construction. Hence, is a proper extension of for all stages , and once&#10;is defined at a stage , it is never redefined again. Therefore, exists&#10;and is an isomorphism from to .\&#10;**Claim 2**. The isomorphism is a computable function.\&#10;PROOF OF CLAIM 2. Let . To determine we run through the stages of the&#10;construction until is defined on . By the assumption that the branching&#10;function and branch isomorphism function for both structures are&#10;computable, we can easily see that the construction is computable at&#10;every stage. Therefore, we can effectively determine the image of under&#10;.\&#10;The construction of a computable isomorphism from to is almost identical&#10;to the one presented above. The only difference is that at stage , after&#10;mapping to at stage , we must then determine via the branching functions&#10;whether and have non-cyclic pre-images. If they don’t, then and are&#10;trivially computably isomorphic. Otherwise, we find the non-cyclic&#10;pre-images of both and (which, of course, can be done computably), then&#10;define as a map from the non-cyclic pre-image of to that of .&#10;&#10;It is worth noting that the construction in Lemma 2.9 can be done&#10;without the explicit assumption that and are computable.\&#10;We conclude this section with our main theorem, which gives a general&#10;sufficient condition for a (2,1):1 structure to be computably&#10;categorical.&#10;&#10;Let be a computable (2,1):1 structure without -chains and with and&#10;computable. If for each , has only finitely many k-cycles, then is&#10;computably categorical.&#10;&#10;Suppose that is a (2,1):1 structure as described above, and is a&#10;computable structure isomorphic to . For each , has only finitely many&#10;k-cycles, and thus has only finitely many cyclic elements in those&#10;k-cycles, which we can computably identify. So we can non-uniformly and&#10;isomorphically map each of these cyclic elements in to a corresponding&#10;cyclic element in via a computable function. Then, by Lemma 2.9, we can&#10;construct a computable isomorphism from to for . Let . Then is a&#10;computable isomorphism from the k-cycles in to those in .&#10;&#10;Repeat the procedure above for each , and let . Since has no -chains,&#10;every element in is in some k-cycle of . So, is a computable isomorphism&#10;from to . Thus, is computably categorical.">
</outline>
<outline text="Examples" _note="In this section, we present some examples of (2,1):1 structures with&#10;various computability-theoretic properties. Our first example&#10;illustrates our point from Section 2 that computability of a (2,1):1&#10;structure does not guarantee computability of its branching function&#10;(nor its branch isomorphism function).&#10;&#10;There exists a computable (2,1):1 structure such that is not computable.&#10;&#10;Our goal is to construct a computable (2,1):1 structure such that is not&#10;a computable set. So let be some computably enumerable set that contains&#10;and is not computable. Then has a partial computable characteristic&#10;function such that if , and if (i.e., computes forever, that is, never&#10;halts on input ). In stages, we build to be a single 1-cycle.\&#10;STAGE 0: Let , and let .&#10;&#10;STAGE 1: Let , and let and .&#10;&#10;STAGE S+1: Suppose we have and from stage . Find the least such that&#10;&#10;, and&#10;&#10; (i.e., halts and equals 1 on input in at most steps of its&#10;computation).&#10;&#10;If no such exists, simply extend to and to by attaching one new number&#10;(not already in ) to each number in . Then move on to the next stage.&#10;&#10;If such an does exist, take the least number not already in and define .&#10;Denote the level of in by , and extend the TREE of by attaching new&#10;numbers to such that for . Then extend to by attaching one new number to&#10;each number in . Define and continue extending to accordingly. Then move&#10;on to the next stage.&#10;&#10;Finally, let and . This completes the construction of . We must now&#10;verify two claims.\&#10;**Claim 1**: is a computable (2,1):1 structure.\&#10;PROOF OF CLAIM 1: We have that , and is thus clearly computable. To&#10;compute , we simply run through the construction until we reach the&#10;stage where appears, and then determine . Due to the construction, once&#10;is defined on an element, we never redefine it at a later stage. Thus, ,&#10;and is computable. Therefore, is computable.&#10;&#10;To see that is a (2,1):1 structure, first observe that has exactly two&#10;pre-images, and . Also note that at every stage, we extend the exclusive&#10;tree of by one level, so every element has at least one pre-image. The&#10;only instance where an element is given an additional pre-image is if it&#10;had exactly one pre-image, so no element has more than two pre-images.&#10;Thus, every element either has exactly one or exactly two pre-images,&#10;making a (2,1):1 structure.\&#10;**Claim 2**: The branching function is not computable.\&#10;PROOF OF CLAIM 2: Observe that if and only if has two pre-images, which&#10;is if and only if . Thus, is computable if and only if is computable.&#10;However, is not a computable set by assumption. Therefore, cannot be&#10;computable.&#10;&#10;The following example demonstrates that computability of the branching&#10;function does not imply computability of the branch isomorphism&#10;function.&#10;&#10;There exists a computable (2,1):1 structure such that is computable but&#10;is not computable.&#10;&#10;We wish to construct a computable (2,1):1 structure such that is&#10;computable, but no computable function computes the branch isomorphism&#10;function . We will accomplish this by building using a standard priority&#10;argument to ensure that for all , the following requirement is&#10;satisfied:&#10;&#10;We start with an effective enumeration of all partial computable&#10;functions . Our desired structure will again be a single 1-cycle, which&#10;we will construct in stages as follows.\&#10;STAGE 0: Define , and .&#10;&#10;STAGE S+1: Suppose we have and from the previous stage. Let denote the&#10;lowest level of the exclusive tree of 0 at the end of stage , i.e., is&#10;the unique number such that , and for all , .&#10;&#10;First, assign to level , where is the least number such that has not&#10;been assigned to a level of the exclusive tree at a previous stage. Let&#10;denote the level of that has been assigned to, so . (We will only assign&#10;a partial computable function to a level of the exclusive tree that&#10;contains only elements with two pre-images.) Then, find the least such&#10;that:&#10;&#10; for some , and&#10;&#10; has not yet received attention.&#10;&#10;If no such exists, extend to , and to , by attaching two unused even&#10;numbers as pre-images to every number in . Set and go on to the next&#10;stage.&#10;&#10;If such an exists, we say that REQUIRES ATTENTION. If , let and be the&#10;distinct pre-images of , with . Attach two unused odd numbers to every&#10;element that is in both and , and attach two unused even numbers to&#10;every element that is in both and . If , then simply attach one unused&#10;odd number and one unused even number to . In either case, repeat the&#10;procedure for every number in the same level of the exclusive tree of as&#10;. Now, the level of the exclusive tree of is complete.&#10;&#10;Then, to every odd number in , attach exactly one unused even number. To&#10;every even number in , attach exactly two unused even numbers. This&#10;completes the level of the exclusive tree of . Let\&#10; extend to as described above, and set . At this point, has RECEIVED&#10;ATTENTION and we move on to the next stage.&#10;&#10;This ends the construction. Let and . We must now prove the following&#10;two claims.\&#10;**Claim 1**: The structure is a computable (2,1):1 structure with&#10;computable.\&#10;PROOF OF CLAIM 1: By construction, . To compute , we simply run through&#10;the construction until we reach the stage where appears, then determine&#10;. Due to the construction, once is defined on an element, we never&#10;redefine it at a later stage. Thus, , and is computable.&#10;&#10;To see that is a (2,1):1 structure, observe that every even number has&#10;exactly two pre-images, and every odd number has exactly one pre-image.&#10;This also proves that is a computable function.\&#10;**Claim 2**: The branch isomorphism function is not computable.\&#10;PROOF OF CLAIM 2: We prove by induction that each requirement is&#10;satisfied. At stage , is assigned to level of the exclusive tree of , so&#10;is assigned to the single number . If for some stage , then would&#10;require attention at stage . However, due to the construction, the&#10;isomorphism on the branches of 2 would be ruined at stage , and thus for&#10;all stages , and . Hence, is satisfied. Otherwise, for any stage and&#10;thus . But the only requirement that can ruin the isomorphism on the&#10;branches of is . (Any requirement receiving attention only ruins the&#10;isomorphism on the branches of the elements in its assigned level, due&#10;to the symmetry of the construction.) Thus, for all stages , , which&#10;means that . Again, is satisfied.&#10;&#10;Now suppose that for all , is satisfied. At stage , is assigned to some&#10;level . If there do not exist a stage and a number in level such that ,&#10;then is satisfied since for all by the same argument as before.&#10;Otherwise, let be the first stage at which for all , does not require&#10;attention and for some in level . Then at stage , would require&#10;attention, and the construction would ensure that for all stages . So,&#10;and again, would be satisfied. Therefore, all requirements are satisfied&#10;and is not computable.&#10;&#10;The next example illustrates what can go wrong if we relax one of the&#10;conditions in Theorem 2.10, and allow a (2,1):1 structure to have&#10;infinitely many K-cycles of one size.&#10;&#10;There exists a computable (2,1):1 structure with no -chains such that&#10;and are computable, but is not computably categorical.&#10;&#10;We shall first present a computable (2,1):1 structure with the desired&#10;properties, and then construct a computable isomorphic structure that is&#10;not computably isomorphic to .&#10;&#10;Let be the (2,1):1 structure where and is defined as follows:&#10;&#10;\(A) at (1,0)\[label=below:0\]; (B) at (2,0)\[label=below right:1\]; (C)&#10;at (3,0)\[label=below:3\]; (D) at (4,0)\[label=below right:5\]; (E) at&#10;(5,0)\[label=below:7\]; (F) at (6,0)\[label=below right:9\]; (G) at&#10;(7,0)\[label=below:11\]; (H) at (8,0)\[label=below right:13\]; at (9,0)&#10;[]{};&#10;&#10;(B1) at (2,-1)\[label=right:2\]; (B2) at (2,-2)\[label=right:4\]; (B3)&#10;at (2,-3)\[label=right:8\]; (B4) at (2,-3.5)[]{};&#10;&#10;(D1) at (4,-1)\[label=right:6\]; (D2) at (4, -2)\[label=right:12\]; (D3)&#10;at (4, -3)\[label=right:24\]; (D4) at (4, -3.5)[]{};&#10;&#10;(F1) at (6,-1)\[label=right:10\]; (F2) at (6,-2)\[label=right:20\]; (F3)&#10;at (6,-3)\[label=right:40\]; (F4) at (6,-3.5)[]{};&#10;&#10;(H1) at (8,-1)\[label=right:14\]; (H2) at (8,-2)\[label=right:28\]; (H3)&#10;at (8,-3)\[label=right:56\]; (H4) at (8,-3.5)[]{};&#10;&#10;\(A) to \[bend right=45\](1.3,0.3); (1.3,0.3) to \[bend&#10;right=45\](1,0.6); (1,0.6) to \[bend right=45\](0.7,0.3); (0.7,0.3) to&#10;\[bend right=45\](A);&#10;&#10;\(B) to \[bend right=45\](2.3,0.3); (2.3,0.3) to \[bend&#10;right=45\](2,0.6); (2,0.6) to \[bend right=45\](1.7,0.3); (1.7,0.3) to&#10;\[bend right=45\](B);&#10;&#10;\(C) to \[bend right=45\](3.3,0.3); (3.3,0.3) to \[bend&#10;right=45\](3,0.6); (3,0.6) to \[bend right=45\](2.7,0.3); (2.7,0.3) to&#10;\[bend right=45\](C);&#10;&#10;\(D) to \[bend right=45\](4.3,0.3); (4.3,0.3) to \[bend&#10;right=45\](4,0.6); (4,0.6) to \[bend right=45\](3.7,0.3); (3.7,0.3) to&#10;\[bend right=45\](D);&#10;&#10;\(E) to \[bend right=45\](5.3,0.3); (5.3,0.3) to \[bend&#10;right=45\](5,0.6); (5,0.6) to \[bend right=45\](4.7,0.3); (4.7,0.3) to&#10;\[bend right=45\](E);&#10;&#10;\(F) to \[bend right=45\](6.3,0.3); (6.3,0.3) to \[bend&#10;right=45\](6,0.6); (6,0.6) to \[bend right=45\](5.7,0.3); (5.7,0.3) to&#10;\[bend right=45\](F);&#10;&#10;\(G) to \[bend right=45\](7.3,0.3); (7.3,0.3) to \[bend&#10;right=45\](7,0.6); (7,0.6) to \[bend right=45\](6.7,0.3); (6.7,0.3) to&#10;\[bend right=45\](G);&#10;&#10;\(H) to \[bend right=45\](8.3,0.3); (8.3,0.3) to \[bend&#10;right=45\](8,0.6); (8,0.6) to \[bend right=45\](7.7,0.3); (7.7,0.3) to&#10;\[bend right=45\](H);&#10;&#10;(B1) to (B); (B2) to (B1); (B3) to (B2);&#10;&#10;(D1) to (D); (D2) to (D1); (D3) to (D2);&#10;&#10;(F1) to (F); (F2) to (F1); (F3) to (F2);&#10;&#10;(H1) to (H); (H2) to (H1); (H3) to (H2);&#10;&#10;This structure is easily seen to be a computable (2,1):1 structure. We&#10;can also see that if (mod 4), and otherwise. So the function is clearly&#10;computable as well. The branch isomorphism function is trivially&#10;computable, since for all . Finally, is composed entirely of 1-cycles,&#10;and thus contains no -chains. Thus, has all of the desired properties.&#10;&#10;Let denote the halting set. We build an isomorphic copy in stages as&#10;follows.\&#10;STAGE 0: Let and let .&#10;&#10;STAGE S+1: Suppose we are given and from stage . Find the least such&#10;that:\&#10;&#10;, and&#10;&#10;If no such exists, extend to and to by defining . This adds a 1-cycle to&#10;. Also, extend any existing degenerate trees that are attached to a&#10;1-cycle by adding an unused odd number to the end of each one. Go on to&#10;the next stage.&#10;&#10;If such an exists, extend to and to in the following manner. Attach a&#10;degenerate tree of height , composed entirely of unused odd numbers, to&#10;the 1-cycle containing . Then, extend all existing degenerate trees&#10;attached to a 1-cycle by adding an unused odd number to the end of each&#10;one. Add a new 1-cycle by defining . Then go on to the next stage.&#10;&#10;At the end of the construction, let , and . It is easy to see that is a&#10;computable (2,1):1 structure. Also, observe that if and only if . Since&#10;is not computable, both and are infinite, which means that has&#10;infinitely many 1-cycles with degenerate trees attached and infinitely&#10;many 1-cycles with empty trees attached, as does . Thus, .&#10;&#10;However, cannot be computably isomorphic to . This is because is&#10;computable but is not, as the computability of would imply the&#10;computability of . A computable isomorphism from to would preserve the&#10;computability of the split hair set, so no such computable isomorphism&#10;can exist. Therefore, is not computably categorical.&#10;&#10;Note that the conditions in Theorem 2.10 are sufficient for computable&#10;categoricity, but not necessary. By Theorem 1.3, it is possible for a&#10;(2,1):1 structure to have infinitely many K-cycles of the same size and&#10;still be computably categorical.&#10;&#10;[12]{}&#10;&#10;W. Calvert, D. Cenzer, V. Harizanov, and A. Morozov. Effective&#10;categoricity of equivalence structures. ANNALS OF PURE AND APPLIED LOGIC&#10;141 (2006), pp. 61–78.&#10;&#10;D. Cenzer, V. Harizanov, and J.B. Remmel. Computability-theoretic&#10;properties of injection structures. ALGEBRA AND LOGIC 53 (2014), pp.&#10;39–69&#10;&#10;D. Cenzer, V. Harizanov, and J.B. Remmel. Two-to-one structures. JOURNAL&#10;OF LOGIC AND COMPUTATION 23 (2013), pp. 1195–1223&#10;&#10;B. Csima, B. Khoussainov, and J. Liu. Computable categoricity of graphs&#10;with finite components. LECTURE NOTES IN COMPUTER SCIENCE 5028 (2008),&#10;pp. 139–148.&#10;&#10;V.D. Dzgoev and S.S. Goncharov. Autostability of models. ALGEBRA AND&#10;LOGIC 19 (1980), pp. 28–37.&#10;&#10;S. Goncharov, S. Lempp, and R. Solomon. The computable dimension of&#10;ordered abelian groups. ADVANCES IN MATHEMATICS 175 (2003), pp. 102–143&#10;&#10;P. LaRoche. Recursively presented boolean algebras. NOTICES OF THE&#10;AMERICAN MATHEMATICAL SOCIETY 24 (1977), A552–A553.&#10;&#10;S. Lempp, C. McCoy, R. Miller, and R. Solomon. Computable categoricity&#10;of trees of finite height. JOURNAL OF SYMBOLIC LOGIC 70 (2005), pp.&#10;151–215.&#10;&#10;R. Miller. The computable dimension of trees of infinite height. JOURNAL&#10;OF SYMBOLIC LOGIC 70 (2005), pp. 111–141&#10;&#10;J.B. Remmel. Recursive isomorphism types of recursive boolean algebras.&#10;JOURNAL OF SYMBOLIC LOGIC 46 (1981), pp. 572–594.&#10;&#10;J.B. Remmel. Recursively categorical linear orderings. PROCEEDINGS OF&#10;THE AMERICAN MATHEMATICAL SOCIETY 83 (1981), pp. 387–391&#10;&#10;R.I. Soare. RECURSIVELY ENUMERABLE SETS AND DEGREES. A STUDY OF&#10;COMPUTABLE FUNCTIONS AND COMPUTABLY GENERATED SETS. Spring-Verlag,&#10;Berlin, 1987.">
</outline>
  </body>
</opml>