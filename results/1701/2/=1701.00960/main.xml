<?xml version="1.0" encoding="UTF-8"?>
<opml version="2.0">
  <head>
    <title>An Event-B framework\
for the validation of Event-B refinement plugins\
(ongoing work)</title>
    <abstract>We propose an Event-B framework for modeling the underlying theoretical
foundations of Event-B. The aim of this framework is to reuse, for
Event-B itself, the refinement development process. This framework
introduces first, a functional kernel through an Event-B context, then,
it defines Event-B projects, their static and dynamic semantics through
Event-B machines. We intend to use this framework for the validation of
Event-B plugins related to distribution and for Event-B extensions
related to composition and decomposition. </abstract>
  </head>
  <body>
<outline text="Introduction" _note="Event-B  is a method that has been proposed for building formal models&#10;together with their proofs. As a matter of fact, it has been used for a&#10;large range of applications. Nevertheless, it seems that, in general, it&#10;has not been applied to the field of software engineering by itself. In&#10;this paper, we report on an Event-B meta-framework and two software&#10;engineering applications for which the use of the Event-B methodology&#10;seemed to us worth to apply.&#10;&#10;The rest of the paper is organized as follows. Section 2 outlines the&#10;main features of an Event-B framework. Section 3 discusses about two&#10;software applications. In conclusion, Section 4 considers some related&#10;work and sketch future work directions.">
</outline>
<outline text="Towards an Event-B meta-level framework" _note="The proposed meta-level framework aims at validating Event-B model&#10;transformations. We focus on transformations linked to a top-down,&#10;refinement-based development process. Their goal is to assist the user&#10;in producing refinements of his model through patterns parameterized&#10;with the help of domain specific languages. Thus, a transformation&#10;pattern takes as input an Event-B machine and some parameters. It&#10;produces either a single machine or a set of machines. In the latter&#10;case, it is necessary to model the project level – not a single machine&#10;– in order to consider the interaction of the machines of the project.&#10;However, to make things simpler, we consider neither contexts, nor&#10;refinement links between machines. Refinement will be taken into account&#10;at the meta level, each transformation producing a refinement of the&#10;project.">
  <outline text="Methodology" _note="We now propose a meta-level specification of an Event-B project in&#10;Event-B itself. The difficulty of such an exercise is to find the right&#10;level of abstraction and to identify which features should be modeled as&#10;constants and as variables. It is strongly linked with the objectives we&#10;have fixed. First, given the patterns we envision, predicates and&#10;expressions should be left as abstract as possible. Second, we target&#10;operations which should modify the project by adding new machines. Two&#10;orthogonal dynamics will thus be considered: project contents evolution&#10;and project operational semantics. Furthermore, we try to use a&#10;refinement-based approach to specify the meta-level: its features will&#10;be introduced incrementally.">
  </outline>
  <outline text="The global view" _note="Figure \[mch\] describes the overall structure of a machine as a class&#10;diagram. The conversion to Event-B is performed as follows:&#10;&#10;`Machine` is introduced as a set, with `Machines` being the subset of&#10;existing machines.&#10;&#10;Machine attributes and operations can be updated and are defined as&#10;variables.&#10;&#10;`Predicate`, `Ident` and `EventName`. `Ident` is partionned into `Var`,&#10;`Prime` denoting primed versions of machine variables and `Param`.&#10;&#10;`Event` is modeled as a triple with three projections (`Pars`, `Guard`&#10;and `Action`).">
  </outline>
  <outline text="The functional kernel" _note="The functional kernel introduces abstraction of predicates and events as&#10;Event-B contexts. A predicate is defined as a set of abstract states. It&#10;is mainly characterized by axioms stating the existence of the `Free`&#10;function returning the set of the free variables of a predicate and the&#10;substitution function. With respect to our specific needs concerning&#10;decomposition/composition and distribution we also assume the existence&#10;of a `Conjuncts` function returning a set of predicates of which&#10;conjunct is equivalent to the initial predicate. For instance, the&#10;conjuncts of “p = TRUE” is “{ p = TRUE }” and the conjuncts of “p = TRUE&#10;v = 2” is “{ p = TRUE, v = 2 }”. An excerpt of of the Predicate context&#10;is the following:&#10;&#10;`context cPredicate extends cIdent`\&#10;\&#10;`sets State`\&#10;\&#10;`constants Predicate Free Subst Proj Conjuncts ...`\&#10;\&#10;`axioms`\&#10;`  @Predicate_def Predicate = ℙ(State)`\&#10;`  @Free_ty Free ∈ Predicate → ℙ(Ident)`\&#10;`  @Subst_ty Subst ∈ (Ident ⇸ Ident) → (Predicate → Predicate)`\&#10;`  @Proj_ty Proj ∈ ℙ(Ident) → (Predicate → Predicate)`\&#10;`  @Conjuncts_ty Conjuncts ∈ Predicate → ℙ1(Predicate)`\&#10;`  @Conjuncts_ax ∀ p· p ∈ Predicate ⇒  inter(Conjuncts(p)) = p`\&#10;`  @Free_Conjuncts ∀ p· p ∈ Predicate ⇒  union(Free[Conjuncts(p)]) = Free(p)`\&#10;` ...`">
  </outline>
  <outline text="The Event-B project structure" _note="Besides contexts, Event-B projects are modelled through the following&#10;refinement steps:&#10;&#10;`mProject` defines the overall structure of machines and a project as a&#10;set of machines and provides an event to add a machine to a project.&#10;&#10;`static_semantics` adds wellformedness rules concerning the usage of&#10;identifiers within predicates. Machine addition is restricted to well&#10;formed machines.&#10;&#10;`dynamics` adds the invariant preservation property and provides a&#10;dynamic semantics to a project through the introduction of a state and&#10;of the `step` event defining the operational semantics of the project.">
  </outline>
  <outline text="Event-B project and machines" _note="An Event-B project is seen as a set of machines. Each machine has&#10;variables, an invariant and a set of events indexed by event names. In&#10;order to make easier the meta-level reasoning, we consider that a&#10;machine has a unique invariant and that an event has a unique guard and&#10;a unique action (seen as a before-after predicate). These predicates&#10;will be seen as conjunctive later.&#10;&#10;`machine mProject sees cMachine cEvent `\&#10;\&#10;`variables Machines mVars mInv mEvents `\&#10;\&#10;`invariants`\&#10;`  @machines_ty Machines ⊆ Machine`\&#10;`  @mVars_ty mVars ∈ Machines → ℙ(Var)`\&#10;`  @mEvents_ty mEvents ∈ Machines → (EventName ⇸ Event)`\&#10;`  @mInvs_ty mInv ∈ Machines → Predicate`\&#10;`events`\&#10;`  ...`\&#10;`end`&#10;&#10;The `mProject` machine also provides the `new_machine` event for adding&#10;machines to a project. Its takes seven parameters specifying the set of&#10;machines to be added and for each of them a set of variables, an&#10;invariant, event names, and parameters, guard and action of each event.">
  </outline>
  <outline text="The static semantics" _note="The static semantics specifies visibility constraints for variables and&#10;parameters:&#10;&#10;an invariant of a machine uses variables of this machine[^1]&#10;&#10;a guard of an event can use parameters of this event and variables of&#10;the machine the event belongs to.&#10;&#10;an action of an event can use parameters of this event, variables of the&#10;machine and their primed versions.&#10;&#10;`machine static_semantics refines mProject`\&#10;`sees cMachine`\&#10;\&#10;`variables Machines mVars mInv mEvents `\&#10;\&#10;`invariants`\&#10;`  @mInv_ctr ∀ m · m ∈ Machines ⇒ Free(mInv(m)) ⊆ mVars(m)`\&#10;`  @mGuards_ctr `\&#10;`     ∀ m,e· m ∈ Machines ∧ e ∈ dom(mEvents(m))`\&#10;`       ⇒ Free((mEvents(m);Guard)(e)) ⊆ mVars(m) ∪ (mEvents(m);Pars)(e)`\&#10;`  @mActions_ctr `\&#10;`      ∀ m,e· m ∈ Machines ∧ e ∈ dom(mEvents(m))`\&#10;`       ⇒ Free((mEvents(m);Action)(e)) ⊆ mVars(m) ∪ Next[mVars(m)] ∪ (mEvents(m);Pars)(e)`&#10;&#10;[^1]: For the moment, we do not take into account refinements and&#10;    consequently the gluing invariant.">
  </outline>
  <outline text="The dynamic semantics" _note="This refinement takes into account the dynamic of a project. First,&#10;standard proof obligations are added to express that the machine&#10;invariant is preserved by each event. The expression of proof&#10;obligations takes advantage of the representation of a predicate as a&#10;set: conjunction and implication are replaced by intersection and set&#10;inclusion. Second the operational semantics of a project is defined&#10;through the introduction of a state for the subset of machines&#10;considered to be active, and a `step` event modelling the evolution of&#10;the state. The state is declared as a decomposable predicate over&#10;machine variables. It abstracts the usual view of a state as a valuation&#10;of each state variable. Machine invariants should be satisfied by the&#10;state.&#10;&#10;`machine dynamics refines static_semantics`\&#10;`sees cMachine cEvent`\&#10;\&#10;`variables Machines mVars mInv mEvents state`\&#10;\&#10;`invariants`\&#10;`  @state_ty state ∈ Machines ⇸ Decomposable     // only defined on active machines`\&#10;`  @state_dync ∀m· m ∈ dom(state) ⇒ state(m) ⊆ mInv(m)`\&#10;`  @free_state ∀m· m ∈ dom(state) ⇒ Free(state(m)) ⊆ mVars(m)`\&#10;`  @mInv ∀m,e· m ∈ Machines ∧ e ∈ dom(mEvents(m))`\&#10;`           ⇒  mInv(m) ∩ (mEvents(m);Guard)(e) ∩ (mEvents(m);Action)(e) ⊆ Subst(Next)(mInv(m))`&#10;&#10;The `step` event makes a machine of the project advance by updating its&#10;state. It takes as parameters a machine `m`, an event name `e`, a&#10;predicate `p` specifying the value of the parameters. The event guards&#10;are supposed to be satisfied by the current state of the machine. Then&#10;its state is updated by applying the machine action. The new state is&#10;obtained by suppressing primed in the projection on primed variables of&#10;the conjunction of the old state, the parameters and action predicates.&#10;&#10;`  event step`\&#10;`    any m e p`\&#10;`    where`\&#10;`      @m_ty m ∈ dom(state)`\&#10;`      @e_ty e ∈ dom(mEvents(m))`\&#10;`      @p p ∈ Predicate`\&#10;`      @f Free(p) ⊆ Param`\&#10;`      @g state(m) ∩ p ⊆ (mEvents(m);Guard)(e)`\&#10;`    then`\&#10;`      @a state(m) ≔ Subst(Next∼)(Proj(Next[mVars(m)])(state(m) ∩ p ∩ (mEvents(m);Action)(e)))`\&#10;`  end`&#10;&#10;We also introduce an event to change the active set of machines: some&#10;OLD machines can be replaced by NEW machines taken in the pool of&#10;currently inactive machines. This event can be seen as a hot replacement&#10;of components. It should be transparent. For this purpose, we suppose&#10;that the conjunction of old machine states is equal to the conjunction&#10;of new machine states. A typical application will be to replace a&#10;compound machine by its subcomponents once it has been split.">
  </outline>
</outline>
<outline text="Case studies" _note="We have experimented the above meta description on two Event-B model&#10;transformations. The first transformation deals with a safe refinement&#10;development process for distributed applications  . This development&#10;process proposes successive steps for splitting and scheduling complex&#10;events. These steps are defined by refinement patterns. They are&#10;specified through domain specific languages. From these specifications,&#10;two refinements were generated. In the first phase of this work, the&#10;generated refinements had to be verified through the Event-B framework,&#10;i.e., the Rodin verification platform. With respect to that work, our&#10;motivation was to assert that the application of the proposed patterns&#10;actually produce refinements of the source machine, so that the&#10;generated machines are CORRECT BY CONSTRUCTION. Thus, it should not be&#10;necessary to validate these refinements for each application of the&#10;corresponding pattern. The second transformation deals with Event-B by&#10;itself. Actually, the last developments of Event-B propose to enhance&#10;Event-B by decomposition methods. This has lead to two proposals: the&#10;state-based  and the event-based . Both methods have strong theoretical&#10;foundations. Moreover, they have been validated by significant&#10;applications and have been both implemented by plugins available through&#10;the Rodin platform . With respect to these studies, our second&#10;motivation was how to MANAGE THE THEORETICAL BACKGROUND that is required&#10;for the justification of Event-B enhancements like decomposition&#10;methods.">
</outline>
<outline text="Related Work and Conclusion" _note="It is interesting to cite related works which have some connections with&#10;ours. First, Iliasov et al.  is a pioneering work for dealing with the&#10;automation of development steps. For this purpose, they propose the&#10;notion of refinement patterns. Such refinement patterns contain a&#10;syntactic description, applicability conditions and proof obligations&#10;ensuring correctness preservation. Unlike our approach where we stayed&#10;within an Event-B world, adopt specific languages for representing&#10;Event-B models and their so-called transformation rules. Last, the reuse&#10;of the Event-B proof engine is not immediate. Also, Cata[ñ]{}o et al. &#10;adopt the so-called OWN MEDICINE APPROACH in the sense that they adopt&#10;Event-B for formalizing Event-B and JML and the Rodin platform to&#10;discharge their proof obligations. With respect to that our work is&#10;similar. However, their model is mainly functional and their&#10;transformations are defined as functions. Their correctness is stated&#10;through theorems. With respect to Event-B, we have gone further since we&#10;have adopted a state-based approach. The dynamic semantics as well as&#10;model transformations are defined as events. The correctness of the&#10;dynamic semantics and of the transformations are obtained for free&#10;through the Event-B refinement. Moreover, Cata[ñ]{}o et al.  are&#10;concerned neither by the validation of refinement patterns nor by the&#10;semantics of composition.&#10;&#10;To conclude, Event-B proposes a refinement-based development method. In&#10;this paper, we have studied how to support such a development method by&#10;itself in order to formalize the underlying theoretical background: the&#10;so-called meta level. The elaborated framework can also be used to&#10;support Event-B enhancements as composition and decomposition methods.&#10;As future work, we envision to broaden the coverage of our framework. We&#10;are also interested in formalizing the links between Event-B and&#10;temporal or temporized  logics. More generally, the excplicit&#10;description of dynamic behaviours through temporized patterns  within an&#10;Event-B framework looks challenging.">
</outline>
  </body>
</opml>