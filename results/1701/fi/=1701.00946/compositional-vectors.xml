<opml version="2.0">
  <head>
    <title>  \
Joint Semantic Synthesis and Morphological Analysis of the Derived Word</title>
    <abstract>Much like sentences are composed of words, words themselves are composed
of smaller units. For example, the English word [[QUESTIONABLY]{}]{} can
be analyzed as [[QUESTION]{}]{}[[ABLE]{}]{}[[LY]{}]{}. However, this [
STRUCTURAL]{} decomposition of the word does not directly give us a
SEMANTIC representation of the word&#8217;s meaning. Since morphology obeys
the principle of compositionality, the semantics of the word can be
systematically derived from the meaning of its parts. In this work, we
propose a novel probabilistic model of word formation that captures both
the ANALYSIS of a word into its constituent segments and the SYNTHESIS
of the meaning of from the meanings of those segments. Our model jointly
learns to SEGMENT words into morphemes and COMPOSE distributional
semantic vectors of those morphemes. We experiment with the model on
English CELEX data and German DErivBase data. We show that jointly
modeling semantics increases both segmentation accuracy and morpheme by
between 3% and 5%. Additionally, we investigate different models of
vector composition, showing that recurrent neural networks yield an
improvement over simple additive models. Finally, we study the degree to
which the representations correspond to a linguist&#8217;s notion of
morphological productivity. </abstract>
  </head>
  <body>
<outline text="#1">
</outline>
<outline _note="In most languages, words decompose further into smaller units, termed morphemes. For example, the English word [[QUESTIONABLY]{}]{} can be analyzed as [[QUESTION]{}]{}[[ABLE]{}]{}[[LY]{}]{}. This [ STRUCTURAL]{} decomposition of the word, however, by itself is not a SEMANTIC representation of the word&#8217;s meaning;[^1] we further require an account of how to synthesize the meaning from the decomposition. Fortunately, words&#8212;just like phrases&#8212;to a large extent obey the principle of compositionality: the semantics of the word can be systematically derived from the meaning of its parts.[^2] In this work, we propose a novel joint probabilistic model of word formation that captures both STRUCTURAL DECOMPOSITION of a word into its constituent segments and the SYNTHESIS of &#8217;s MEANING from the meaning of those segments.  Morphological segmentation is a structured prediction task that seeks to break a word up into its constituent morphemes. The output segmentation has been shown to aid a diverse set of applications, such as automatic speech recognition , keyword spotting , machine translation and parsing . In contrast to much of this prior work, we focus on [SUPERVISED]{} segmentation, i.e., we provide the model with gold segmentations during training time. Instead of SURFACE segmentation, our model performs CANONICAL segmentation , i.e., it allows the induction of orthographic changes together with the segmentation, which is not typical. For the example [[QUESTIONABLY]{}]{}, our model can restore the deleted characters [[LE]{}]{}, yielding the canonical segments [[QUESTION]{}]{}, [[ABLE]{}]{} and [[LY]{}]{}. In this work, our primary contribution lies in the integration of continuous semantic vectors into supervised morphological segmentation&#8212;we present a joint model of morphological analysis and semantic synthesis at the word-level.  We experimentally investigate three novel aspects of our model.  First, we show that jointly modeling continuous representations of the semantics of morphemes and words allows us to improve morphological analysis. On the English portion of CELEX , we achieve a 5 point improvement in segmentation accuracy and a 3 point improvement in morpheme . On the German DErivBase dataset we achieve a 3 point improvement in segmentation accuracy and a 3 point improvement in morpheme .  Second, we explore improved models of vector composition for synthesizing word meaning. We find a recurrent neural network improves over previously proposed additive models. Moreover, we find that more syntactically oriented vectors are better suited for morphology than bag-of-word (BOW) models.  Finally, we explore the productivity of English derivational affixes in the context of distributional semantics.  [^1]: There are many different linguistic and computational theories for     interpreting the structural decomposition of a word. For example,     [[UN-]{}]{} often signifies negation and its effect on semantics can     then be modeled by theories based on logic. This work addresses the     question of structural decomposition and semantic synthesis in the     general framework of distributional semantics.  [^2]: Morphological research in theoretical and computational     linguistics often focuses on noncompositional or less compositional     phenomena&#8212;simply because compositional derivation poses fewer     interesting research problems. It is also true that&#8212;just as many     frequent multiword units are not completely compositional&#8212;many     frequent derivations (e.g., [[REFUSAL]{}]{}, [[FITNESS]{}]{}) are     not completely compositional. An indication that non-lexicalized     derivations are usually compositional is the fact that standard     dictionaries like list derivational affixes with their compositional     meaning, without a hedge that they can also occur as part of only     partially compositional forms. See also , &#167;5.3.6." text="Introduction">
</outline>
<outline _note="Two important goals of morphology, the linguistic study of the internal structure of words, are to describe the relation between different words in the lexicon and to decompose them into [ MORPHEMES]{}, the smallest linguistic unit bearing meaning. Morphology can be divided into two types: [INFLECTIONAL]{} and [ DERIVATIONAL]{}. Inflectional morphology is the set of processes through which the word form outwardly displays syntactic information, e.g., verb tense. It follows that an inflectional affix typically neither changes the part-of-speech (POS) nor the semantics of the word. For example, the English verb [[TO RUN]{}]{} takes various forms: [[RUN]{}]{}, [[RUNS]{}]{}, [[RAN]{}]{} and [[RUNNING]{}]{}, all of which convey &#8220;moving by foot quickly&#8221;, but appear in complementary syntactic contexts.  Derivation deals with the formation of new words that have semantic shifts in meaning (often including POS) and is tightly intertwined with lexical semantics . Consider the example of the English noun [[DISCONTENTEDNESS]{}]{}, which is derived from the adjective [[DISCONTENTED]{}]{}. It is true that both words share a close semantic relationship, but the transformation is clearly more than a simple inflectional marking of syntax. Indeed, we can go one step further and define a chain of words [[CONTENT]{}]{} [[CONTENTED]{}]{} [[DISCONTENTED]{}]{} [[DISCONTENTEDNESS]{}]{}.  In the computational literature, derivational morphology has received less attention than inflectional. There are, however, two bodies of work on derivation in computational linguistics. First, there is a series of papers that explore the relation between lexical semantics and derivation . All of these assume a gold morphological analysis and primarily focus on the effect of derivation on distributional semantics. The second body of work, e.g., the unsupervised morphological segmenter [[Morfessor]{}]{} , does not deal with semantics and makes [NO DISTINCTION]{} between inflectional and derivational morphology.[^1] Even though the boundary between inflectional and derivational morphology is a continuum rather than a rigid divide , there is still the clear distinction that derivation changes meaning whereas inflection does not. Our goal in this paper is to develop an account of how the meaning of a word form can be computed jointly, combining these two lines of work.  We highlight two related issues in derivation that motivated the development of our model: productivity and semantic coherence. Roughly, a [PRODUCTIVE]{} affix is one that can still actively be employed to form new words in a language. For example, the English nominalizing affix [[NESS]{}]{} ([[RED]{}]{}[[RED]{}]{}[[NESS]{}]{}) can be attached to just about any adjective, including novel forms. In contrast, the archaic English nominalizing affix [[TH]{}]{} ([[DEAR]{}]{}[[DEAR]{}]{}[[TH]{}]{}, [[HEAL]{}]{}[[HEAL]{}]{}[[TH]{}]{}, [[STEAL]{}]{}[[STEAL]{}]{}[[TH]{}]{}) does not allow us to form new words such as [[CHEAPTH]{}]{}. This is a crucial issue in derivational morphology since we would not in general want to analyze new words as having been formed from non-productive endings; e.g., we do not want to analyze [[HEARTH]{}]{} as [[HEAR]{}]{}[[TH]{}]{} (or [[WUGTH]{}]{} as [[WUG]{}]{}[[TH]{}]{}). Relations such as those between [[HEAL]{}]{} and [[HEALTH]{}]{} are [LEXICALIZED]{} since they no longer can be derived by productive processes .  Under a generative treatment of morphology, productivity becomes a central notion since a grammar needs to account for active word formation processes in the language . Defining productivity precisely, however, is tricky; writes, [&#8220;ONE OF THE CENTRAL MYSTERIES OF DERIVATIONAL MORPHOLOGY &#8230;&#160;  &#8230;&#160;THOUGH MANY THINGS ARE POSSIBLE IN MORPHOLOGY, SOME ARE MORE POSSIBLE THAN OTHERS.&#8221;]{} Nevertheless, speakers often have clear intuitions about which affixes in the language are productive.[^2]  Related to productivity is the notion of [SEMANTIC COHERENCE]{}. The principle of compositionality applies to interpretation of words just as it does to phrases. Indeed, compositionality is often taken to be a signal for productivity . When deciding whether to further decompose a word, asking whether the parts sum up to the whole is often a good indicator. In the case of [[QUESTIONABLY]{}]{} [[QUESTION]{}]{}[[ABLE]{}]{}[[LY]{}]{}, the compositional meaning is &#8220;in a manner that could be questioned&#8221;, which corresponds to the meaning of the word. Contrast this with the word [[UNQUIET]{}]{}, which means &#8220;restless&#8221;, rather than &#8220;not quiet&#8221; and the compound [[BLACKMAIL]{}]{}, which does not refer to a letter written in black ink.  The model we will describe in is a JOINT MODEL OF BOTH SEMANTIC COHERENCE AND SEGMENTATION; that is, an analysis is judged not only by character-level features, but also by the degree to which the word is semantically compositional. Implicit in such a treatment is the desire to only segment a word if the segmentation is derived from a productive process. While most prior work on morphological segmentation has not explicitly modeled productivity,[^3] we believe, from a computational modeling perspective, segmenting only productive affixes is preferable. This is analogous to the modeling of phrase compositionality in embedding models, where it can be better to not further decompose noncompositional multiword units like named entities and idiomatic expressions; see, e.g., , , , , and .[^4]  In this paper, we refer to the semantic aspect of the model either as SEMANTIC SYNTHESIS or as COHERENCE. These are two ways of looking at semantics that are related as follows. If the synthesis (i.e., composition) of the meaning of the derived form from the meaning of its parts is a regular application of the linguistic rules of derivation, then the meaning so constructed is coherent. These are the cases where a joint model is expected to be beneficial for both segmentation and interpretation.  [^1]: also make no distinction between inflectional and derivational     morphology, but their model is an exception in that it includes     vector similarity as a semantic feature. See for discussion.  [^2]: It is also important to distinguish productivity from [     CREATIVITY]{}&#8212;a non-rule-governed form of word formation . As an     example of creativity, consider the creation of portmanteaux, e.g.,     [[DRAMEDY]{}]{} and [[SOUNDSCAPE]{}]{}.  [^3]: Note that segmenters such as [Morfessor]{} utilize the principle     of minimum description length, which implicitly encodes     productivity, in order to guide segmentation.  [^4]: As a reviewer points out, productivity of an affix and semantic     coherence of the words formed from it are not perfectly aligned.     Nonproductive affixes can produce semantically coherent words, e.g.,     [[WARM]{}]{}[[WARM]{}]{}[[TH]{}]{}. Productive affixes can produce     semantically incoherent words, e.g.,     [[CANNY]{}]{}[[UN]{}]{}[[CANNY]{}]{}. Again, this is analogous to     multiword units. However, there is a strong correlation and our     experiments show that relying on it gives good results." text="Derivational Morphology">
</outline>
<outline _note="From an NLP perspective, canonical segmentation is the task that seeks to algorithmically decompose a word into its [CANONICAL]{} sequence of morphemes. It is a version of morphological segmentation that requires the learner to handle orthographic changes that take place during word formation. We believe this is a more natural formulation of morphological analysis&#8212;especially for the processing of derivational morphology&#8212;as it draws heavily on linguistic notions (see ).  The main innovation we present is the augmentation of canonical segmentation to take into account semantic coherence and productivity. Consider the word [[HYPERCURIOSITY]{}]{} and its canonical segmentation [[HYPER]{}]{}[[CURIOUS]{}]{}[[ITY]{}]{}; this canonical segmentation seeks to decompose the word into its constituent morphemes and account for orthographic changes. This amounts to a [STRUCTURAL]{} decomposition of the word, i.e., how do we break up the string of characters into chunks? This is similar to the decomposition of a sentence into a parse tree. However, it is also natural to consider the [SEMANTIC]{} compositionality of a word, i.e., how is the meaning of the word synthesized from the meaning of the individual morphemes?  We consider both of these questions together in a single model, where we would like to place high probability on canonical segmentations that are also semantically coherent. Returning to [[HYPERCURIOSITY]{}]{}, we could further decompose it into [[HYPER]{}]{}[[CURE]{}]{}[[OUS]{}]{}[[ITY]{}]{} in analogy to, say, [[VICE]{}]{} [[VICIOUS]{}]{}. Nothing about the surface form of [CURIOUS]{} alone gives us a strong cue that we should rule out the segmentation [[CURE]{}]{}[[OUS]{}]{}. Turning to distributional semantics, however, it is the case that the contexts in which [[CURIOUS]{}]{} occurs are quite different from those in which [[CURE]{}]{} occurs. This gives us a strong cue which segmentation is correct.  Formally, given a word string , where is a discrete alphabet of characters (in English this could be as simple as the 26 letter lowercase alphabet), and a word vector , where is a set of low-dimensional word embeddings, we define the model as: This model is composed of three factors: a composition factor, a segmentation factor and a transduction factor. The parameters of the model are , the function composes morpheme vectors together, is the segmentation, is the labeling of the segments, is the underlying representation and is the partition function. Note that the conditional distribution is Gaussian distributed by construction. A visualization of our model is found in . This model is a conditional random field (CRF) that is mixed, i.e., it is defined over both discrete and continuous random variables . We restrict the range of to be a subset of , where is an insertion limit . In this work, we take . Explicitly, the partition function is defined as which is guaranteed to be finite.[^1]  A CRF is simply the globally renormalized product of several non-negative factors . Our model is composed of three: transduction, segmentation and composition factors&#8212;we describe each in turn.  [^1]: Since we have capped the insertion limit, we have a finite number     of values that can take for any . Thus, it follows that we have a     finite number of canonical segmentations . Hence we take a finite     number of Gaussian integrals. These integrals all converge since we     have fixed the covariance matrix as , which is positive definite.The first factor we consider is the transduction factor: , which scores a [ SURFACE REPRESENTATION]{} (SR) , the character string observed in raw text, and an [UNDERLYING REPRESENTATION]{} (UR), a character string with orthographic processes reversed. The aim of this factor is to place high weight on good pairs, e.g., the pair (=[[QUESTIONABLY]{}]{},=[[QUESTIONABLELY]{}]{}), so we can accurately restore character-level changes.  We encode this portion of the model as a weighted finite-state machine for ease of computation. This factor generalizes probabilistic edit distance by looking at additional input and output context; see for details. As mentioned above and in contrast to , we bound the insertion limit in the edit distance model.[^1] Computing the score between two strings and requires a dynamic program that runs in . This is a generalization of the forward algorithm for Hidden Markov Models (HMMs) .  We employ standard feature templates for the task that look at features of edit operations, e.g., substitute for , in varying context granularities. See for details. Recent work has also explored weighting of WFST arcs with scores computed by LSTMs , obviating the need for human selection of feature templates .  [^1]: As our transduction model is an unnormalized factor in a CRF, we     do not require the local normalization discussed in &#8212;a weight on an     edge may be any non-negative real number since we will renormalize     later. The underlying model, however, remains the same. &#10;The second factor is the segmentation factor: . The goal of this factor is to score a segmentation of a UR . In our example, it scores the input-output pair ([[QUESTIONABLELY]{}]{}, [[QUESTION]{}]{}[[ABLE]{}]{}[[LY]{}]{}). It additionally scores a labeling of the segmentation. Our label set in this work is . The proper labeling of the segmentation above is [[QUESTION]{}]{}[ :STEM]{}[[ABLE]{}]{}[:SUFFIX]{}[[LY]{}]{}[:SUFFIX]{}. The labeling is critical for our composition functions : which vectors are used depends on the label given to the segment; e.g., the vectors of the prefix &#8220;post&#8221; and the stem &#8220;post&#8221; are different.  We can view this factor as an unnormalized first-order semi-CRF . Computation of the factor again requires dynamic programming. The algorithm is a different generalization of the forward algorithm for HMMs, one that extends it to the semi-Markov case. This algorithm runs in .  We again use standard feature templates for the task. We create atomic indicator features for the individual segments. We then conjoin the atomic features with left and right context features as well as the label to create more complex feature templates. We also include transition features that fire on pairs of sequential labels. See for details. Recent work has also showed that a neural parameterization can remove the need for manual feature design . &#10;The composition factor takes the form of an unnormalized multivariate Gaussian density: , where the mean is computed by the (potentially non-linear) composition function (See ) and the covariance matrix is a diagonal matrix. The goal of the composition function is to stitch together [ MORPHEME]{} embeddings to approximate the vector of the entire word.  The simplest form of the composition function is ADD, an additive model of the morphemes. See : each vector refers to a morpheme-specific, label-dependent embedding. If , then represents a stem morpheme. Given that our segmentation is canonical, an that is a stem generally itself is an entry in the lexicon and . If , then we set to 0.[^1] We optimize over vectors with as they correspond to bound morphemes.  We also consider a more expressive composition model, a recurrent neural network (RNN). Let be the number of segments. Then where is a hidden vector, defined by the recursion:[^2] . Again, we optimize the morpheme embeddings only when along with the other parameters of the RNN, i.e., the matrices and .  [^1]: This is not changed in training, so all such are 0 in the final     model. Clearly, this could be improved in future work as a reviewer     points out, e.g., by setting such to an average of a suitable chosen     set of known word vectors.  [^2]: We do not explore more complex RNNs, e.g., LSTMs and GRUs as words     in our data have 7 morphemes. These architectures make the learning     of long distance dependencies easier, but are no more powerful than     an Elman RNN, at least in theory. Note that perhaps if applied to     languages with richer derivational morphology than English,     considering more complex neural architectures would make sense. &#10;" text="A Joint Model">
  </outline>
<outline _note="Exact inference is intractable since we allow arbitrary segment-level features on the canonicalized word forms . Since the semi-CRF factor has features that fire on substrings, we would need a dynamic programming state for each substring of each of the exponentially many settings of ; this breaks the dynamic program. We thus turn to approximate inference through an importance sampling routine .Rather than considering all underlying orthographic forms and segmentations , we sample from a tractable proposal distribution &#8212;a distribution over canonical segmentations. In the following equations we omit the dependence on for notational brevity and define . Crucially, the partition function is [NOT]{} a function of parameter subvector and its gradient with respect to is 0.[^1] Recall that computing the gradient of the log-partition function is equivalent to the problem of marginal inference . We derive our estimator as follows:  \_ Z &amp;= \_[(l, s,u) \~p]{} &amp;\ &amp;= \_[l, s, u]{} p(l, s, u) [[[h]{}]{}]{}(l, s,u) &amp;\ &amp;= \_[l, s, u]{} p(l, s, u) [[[h]{}]{}]{}(l, s,u) &amp;\ &amp;= \_[(l, s, u) \~q]{},  where we have omitted the dependence on (which we condition on) and (which we marginalize out). So long as has support everywhere does (i.e., ), the estimate is unbiased. Unfortunately, we can only efficiently compute up to a constant factor, . Thus, we use the INDIRECT IMPORTANCE SAMPLING ESTIMATOR, where and importance weights are defined as: This indirect estimator is biased, but consistent.[^2]  The success of importance sampling depends on the choice of a &#8220;good&#8221; proposal distribution, i.e., one that ideally is close to . Since we are fully supervised at training time, we have the option of training locally normalized distributions for the individual components. Concretely, we train [ TWO]{} proposal distributions and that take the form of a WFST and a semi-CRF, respectively, using features identical to the joint model. Each of these distributions is tractable&#8212;we can compute the marginals with dynamic programming and thus sample efficiently. To draw samples , we sample sequentially from and then , conditioned on the output of .  [^1]: The subvector is responsible for computing only the [MEAN]{} of     the Gaussian factor and thus has no impact on its normalization     coefficient .  [^2]: Informally, the indirect importance sampling estimate converges to     the TRUE expectation as (the definition of statistical consistency). &#10;We optimize the log-likelihood of the model using [[AdaGrad]{}]{} , which is SGD with a special per-parameter learning rate. The full gradient of the objective for one training example is: where we use the importance sampling algorithm described in to approximate the gradient of the log-partition function, following . Note that depends on the composition function used. In the most complicated case when is a RNN, we can compute efficiently with backpropagation through time . We take importance samples; using so few samples can lead to a poor estimate of the gradient, but for our application it suffices. We employ regularization. &#10;Decoding the model is also intractable. To approximate the solution, we again employ importance sampling. We take 10,000 importance samples and select the highest weighted sample. &#10;" text="Inference and Learning">
  </outline>
<outline _note="The idea that vector semantics is useful for morphological segmentation is not new. Count vectors have been shown to be beneficial in the unsupervised induction of morphology . Embeddings were shown to act similarly . Our method differs from this line of research in two key ways. (i) We present a PROBABILISTIC model of the process of synthesizing the word&#8217;s meaning from the meaning of its morphemes. Prior work was either not probabilistic or did not explicitly model morphemes. (ii) Our method is supervised and focuses on derivation. and , being fully unsupervised, do not distinguish between inflection and derivation and focus on inflection. More recently, look at the unsupervised induction of &#8220;morphological chains&#8221; with semantic vectors as a crucial feature. Their goal is to jointly figure out an ordering of word formation and a morphological segmentation, e.g., [[PLAY]{}]{}[[PLAYFUL]{}]{}[[PLAYFULNESS]{}]{}. While it is a rich model like ours, theirs differs in that it is unsupervised and uses vectors as features, rather than explicitly treating vector composition. All of the above work focuses on [SURFACE SEGMENTATION]{} and not [CANONICAL SEGMENTATION]{}, as we do.  A related line of work that has different goals concerns morphological generation. Two recent papers that address this problem using deep learning are and . In an older line of work, and exploit log frequency ratios of inflectionally related forms to tease apart that, e.g., the past tense of [[SING]{}]{} is not [[SINGED]{}]{}, but instead [[SANG]{}]{}. Related work by uses a Dirichlet process to model a corpus as a &#8220;mixture of a paradigm&#8221;, allowing for the semi-supervised incorporation of distributional semantics into a structured model of inflectional paradigm completion.  Our work is also related to recent attempts to integrate morphological knowledge into general embedding models. For example, train a log-bilinear language model that models the composition of morphological structure. Likewise, train a recursive neural network over a heuristically derived tree structure to learn morphological composition over continuous vectors. Our work is different in that we learn a joint model of segmentation and composition. Moreover, supervised morphological analysis can drastically outperform unsupervised analysis .  Early work by can be interpreted as finite-state canonical segmentation, but it neither addresses nor experimentally evaluates the question of joint modeling of morphological analysis and semantic synthesis. Moreover, we may view canonicalization as an orthographic analogue to phonology. On this interpretation, the finite-state systems of , which computationally apply SPE-style phonological rules , may be run backwards to get canonical underlying forms." text="Related Work">
</outline>
<outline _note="We conduct experiments on English and German derivational morphology. We analyze our joint model&#8217;s ability to segment words into their canonical morphemes as well as its ability to compositionally derive vectors for new words. Finally, we explore the relationship between distributional semantics and morphological productivity.  For English, we use the pretrained vectors of for all experiments. For German, we train word2vec skip-gram vectors on the German Wikipedia. We first describe our English dataset, the subset of the English portion of the CELEX lexical database that was selected by ; the dataset contains 10,000 forms. This allows for comparison with previously proposed methods. We make two modifications. (i) make the TWO-MORPHEME ASSUMPTION: every word is composed of exactly two morphemes. In general, this is not true, so we further segment all complex words in the corpus. For example, [[FRIENDLESS]{}]{}[[NESS]{}]{} is further segmented into [[FRIEND]{}]{}[[LESS]{}]{}[[NESS]{}]{}. To nevertheless allow for fair comparison, we provide versions of our experiments with and without the two-morpheme assumption where appropriate. (ii) only provide a single train/test split. As we require a held-out development set for hyperparameter tuning, we randomly allocate a portion of the training data to select the hyperparameters and then retrain the model using these parameters on the original train split. We also report 10-fold cross validation results in addition to Lazaridou et al.&#8217;s train/test split.  Our German dataset is taken from and is described in . It, again, consists of 10,000 derivational forms. We report results on 10-fold cross validation.For our first experiment, we test whether jointly modeling the continuous representations allows us to segment words more accurately. We assume that we are given an embedding for the target word. We estimate the model as described in with regularization . To evaluate, we decode the distribution . We perform approximate MAP inference with importance sampling&#8212;taking the sample with the highest score. In these experiments, we use the RNN with the dependency vectors, the combination of which performs best on vector approximation in .  We follow the experimental design of . We compare against two baselines (marked &#8220;Baseline&#8221; in ): (i) a &#8220;Semi-CRF&#8221; segmenter that cannot account for orthographic changes and (ii) the full &#8220;Joint&#8221; model of .[^1] We additionally consider an &#8220;Oracle&#8221; setting, where we give the model the gold underlying orthographic form (&#8220;UR&#8221;) at both training and test time. This gives us insight into the performance of the transduction factor of our model, i.e., how much could we benefit from a richer model.  Our hyperparameters are (i) the regularization coefficient and (ii) , the variance of the Gaussian factor. We use grid search to tune them: , .  [width=.475]{}  We use three metrics to evaluate segmentation accuracy. Note that the evaluation of canonical segmentation is hard since a system may return a sequence of morphemes whose concatenation is not the same length as the concatenation of the gold morphemes. This rules out metrics for surface segmentation like border , which require the strings to be of the same length.  We now define the metrics. (i) SEGMENTATION ACCURACY measures whether every single canonical morpheme in the returned sequence is correct. It is inflexible: closer answers are penalized the same as more distant answers. (ii) MORPHEME takes the predicted sequence of canonical morphemes, turns it into a set, computes precision and recall in the standard way and based on that then computes . This metric gives credit if some of the canonical morphemes were correct. (iii) LEVENSHTEIN DISTANCE joins the canonical segments with a special symbol \# into a single string and computes the Levenshtein distance between predicted and gold strings.  Results in show that jointly modeling semantic coherence improves our ability to analyze words. For test, our proposed joint model (&#8220;This Work&#8221;) outperforms the baseline supervised canonical segmenter, which is state-of-the-art for the task, by .05 (resp.&#160;.03) on accuracy and .03 (resp.&#160;.03) on for English (resp.&#160;German). We also find that when we give the joint model an oracle UR the vectors generally help less: .01 (resp.&#160;.02) on accuracy and .01 (resp.&#160;.03) on for English (resp.&#160;German). This indicates that the chief boon the vector composition factor provides lies in selection of an appropriate UR. Moreover, the up to .15 difference in English between systems with and without the oracle UR suggests that reversing orthographic changes is a particularly difficult part of the task, at least for English.  [^1]: i.e., a model [WITHOUT]{} the Gaussian factor that scores vectors. &#10;We adopt the experimental design of . Its aim is to approximate a vector of a derivationally complex word using a learned model of composition. As assume a gold morphological analysis, we compare two settings: (i) oracle morphological analysis and (ii) inferred morphological analysis. To the best of our knowledge, (ii) is a novel experimental condition that no previous work has addressed.  We consider four composition models (See ). (i) STEM, using just the stem vector. This baseline tells us what happens if we make the incorrect assumption that derivation behaves like inflection and is not meaning-changing. (ii) ADD, a purely additive model. This is arguably the simplest way of combining the vectors of the morphemes. (iii) LDS, a linear dynamical system. This is arguably the simplest sequence model. (iv) A (simple) RNN. Recurrent neural networks are currently the most widely used nonlinear sequence model and simple RNNs are the simplest such models.  Part of the motivation for considering a richer class of models lies in our removal of the two-morpheme assumption. Indeed, it is unclear that the [WADD]{} and [FULLADD]{} models are useful models in the general case of multi-morphemic words&#8212;the weights are tied by [POSITION]{}, i.e., the first morpheme&#8217;s vector (be it a prefix or stem) is always multiplied by the same matrix.  To compare with , we use their exact train/test split. Those results are reported in . This dataset enforces that all words are composed of exactly two morphemes. Thus, a word like [[UNQUESTIONABLY]{}]{} is segmented as [[UN]{}]{}[[QUESTIONABLY]{}]{}, without further decomposition. The vectors employed by are high-dimensional count vectors derived from lemmatized and POS tagged text with a before-and-after window of size 2. They then apply pointwise mutual information (PMI) weighting and dimensionality reduction by non-negative matrix factorization. In contrast, we employ [[word2vec]{}]{} , a model that is also interpretable as the factorization of a PMI matrix . We consider three [[word2vec]{}]{} models: two bag-of-word (BOW) models with before-and-after windows of size 2 and 5 and DEPs , a dependency-based model whose context is derived from dependency parses rather than BOW.  In general, the results indicate that the key to better vector approximation is not a richer model of composition, but rather lies in the vectors themselves. We find that our best model, the RNN, only marginally edges out the LDS. Additionally, looking at the &#8220;all&#8221; column and the DEPs vectors, the simple additive model is only .02 lower than LDS. In comparison, we observe large differences between the vectors. The RNN+DEPs model is .23 better than the BOW5 models (.81 vs.&#160;.58), .14 better than the BOW2 models (.81 vs.&#160;.67) and .25 better than Lazaridou et al.&#8217;s best model (.81 vs.&#160;.56). A wider context for BOW (5 instead of 2) yields worse results. This suggests that syntactic information or at least positional information is necessary for improved models of morpheme composition. The test vectors are annotated for relatedness, which is a proxy for semantic coherence. HR (high-relatedness) words were judged to be more compositional than LR (low-relatedness) words.  As a further strong baseline, we consider a retrofitting approach based on character-level recurrent neural networks. Recently, running a recurrent net over the character stream has become a popular way of incorporating subword information into a model&#8212;empirical gains have been observed in a diverse set of NLP tasks: POS tagging , parsing and language modeling . To the best of our knowledge, character-level retrofitting is a novel approach. Given a vector for a word form , we seek a function to minimize the following objective where is the final hidden state of a recurrent neural architecture, i.e., where is a non-linearity and is the character in , is the previous hidden state and and are matrices. While we have defined the architecture for a vanilla RNN, we experiment with two more advanced recurrent architectures: GRUs and LSTMs as well as deep variants . Importantly, this model has [NO KNOWLEDGE]{} of morphology&#8212;it can only rely on representations it extracts from the characters. This gives us a clear ablation on the benefit of adding structured morphological knowledge. We optimize the depth and the size of the hidden units on development data using a coarse-grained grid search. We found a depth of 2 and hidden units of size 100 (in both LSTM and GRU) performed best. We trained all models for 100 iterations of Adam with regularization with regularization coefficient .  shows that the two character-level models (&#8220;c-GRU&#8221; and &#8220;c-LSTM&#8221;) perform much worse than our models. This indicates that supervised morphological analysis produces higher-quality vector representations than &#8220;knowledge-poor&#8221; character-level models. However, we note that these character-level models have fewer parameters than our morpheme-level models&#8212;there are many more morphemes in a languages than characters.  In general, the two-morpheme assumption is incorrect. We consider an expanded setting of &#8217;s task, in which we fully decompose the word, e.g., [[UNQUESTIONABLY]{}]{}[[UN]{}]{}[[QUESTION]{}]{}[[ABLE]{}]{}[[LY]{}]{}. These results are reported in (top block, &#8220;oracle&#8221;). We report mean cosine similarity. Standard deviations for 10-fold cross-validation (not shown) are small () with two exceptions: for the DEPs-joint-stem results (.411 and .412).  The multi-morphemic results mirror those of the bi-morphemic setting of . (i) RNN+DEPs attains an average cosine similarity of around .80 for English. Numbers for German are lower, around .70. (ii) The RNN only marginally edges out LDS for English and is slightly worse for German. Again, this is not surprising as we are modeling short sequences. (iii) Certain embeddings lend themselves more naturally to derivational compositionality: BOW2 is better than BOW5, DEPs is the clear winner.  The final setting we consider is the vector approximation task without gold morphology. In this case, we rely on the full joint model . At evaluation, we are interested in the marginal distribution . We then use importance sampling to approximate the mean of this marginal distribution as the predicted embedding, i.e., where are the importance weights defined in and and are the sampled labeling and segmentation, respectively.  Surprisingly, (joint) shows that relying on the inferred morphology does not drastically affect the results. Indeed, we are often within .01 of the result with gold morphology. Our method can be viewed as a retrofitting procedure , so this result is useful: it indicates that joint semantic synthesis and morphological analysis produces high-quality vectors. &#10;We now delve into the relation between distributional semantics and morphological productivity. The extent to which jointly modeling semantics aids morphological analysis will be determined by the inherent compositionality of the words within the vector space. We break down our results on the vector approximation task with gold morphology using the dependency vectors and the RNN composer in by selected affixes. We observe a wide range of scores: the most compositional ending [[LY]{}]{} gives rise to cosine similarities that are 20 points higher than those of the least compositional [[ER]{}]{}.  On the left end of we see extremely productive suffixes. The affix [[IZE]{}]{} is used productively with relatively obscure words in the sciences, e.g., [[RAO-BLACKWELLIZE]{}]{}. Likewise, the affix [[NESS]{}]{} can be applied to almost any adjective without restriction, e.g., [[POISSONNESS]{}]{} &#8216;degree to which data have a Poisson distribution&#8217;. On the right end, we find [[-MENT]{}]{}, [[-ER]{}]{} and [[RE-]{}]{}. The affix [[-MENT]{}]{} is borderline productive &#8212;modern English tends to form novel nominalizations with [[NESS]{}]{} or [[ITY]{}]{}. More interesting are [[RE-]{}]{} and , both of which are very productive in English. For [[ER]{}]{}, many of the words bringing down the average are simply non-compositional. For example, [[HOMER]{}]{} &#8216;homerun in baseball&#8217; is not derived from [[HOME]{}]{}[[ER]{}]{}&#8212;this is an error in data. We also see examples like [[CUTTER]{}]{}. It has a compositional reading (e.g., &#8220;box cutter&#8221;), but also frequently occurs in the non-compositional meaning &#8216;type of boat&#8217;. Finally, proper nouns like [[HOMER]{}]{} and [[TURNER]{}]{} end in [[ER]{}]{} and in our experiments we computed vectors for lowercased words. The affix [[RE-]{}]{} similarly has a large number of non-compositional cases, e.g., [[REMOVE]{}]{}, [[RELOCATE]{}]{}, [[REMARK]{}]{}. Indeed, to get the compositional reading of [[REMOVE]{}]{}, the first syllable (rather than the second) is typically stressed to emphasize the prefix.  We finally note several limitations of this experiment. (i) The ability of our models&#8212;even the recurrent neural network&#8212;to model transformations between vectors is limited. (ii) Our vectors are far from perfect; e.g., sparseness in the training data affects quality and some of the words in our corpus are rare. (iii) Semantic coherence is not the only criterion for productivity. An example is [[-TH]{}]{} in English. As noted earlier, it is compositional in a word like [[WARMTH]{}]{}, but it cannot be used to form new words. &#10;" text="Experiments and Results">
  </outline>
<outline _note="We have presented a model of the semantics and structure of derivationally complex words. To the best of our knowledge, this is the first attempt to jointly consider, within a single model, (i) the morphological decomposition of the word form and (ii) the semantic coherence of the resulting analysis. We found that directly modeling coherence increases segmentation accuracy, improving over a strong baseline. Also, our models show state-of-the-art performance on the derivational vector approximation task introduced by .  Future work will focus on the extension of the method to more complex instances of derivational morphology, e.g., compounding and reduplication, and on the extension to additional languages. We also plan to explore the relation between derivation and distributional semantics in greater detail.  The first author was supported by a DAAD Long-Term Research Grant and an NDSEG fellowship and the second by a Volkswagenstiftung Opus Magnum grant. We would also like to thank action editor Regina Barzilay for suggesting several changes we incorporated into the work and the three anonymous reviewers." text="Conclusion">
</outline>
  </body>
</opml>