%!TEX root = ../wbi.tex
\section{Implementation} % (fold)
\label{sec:software_implementation}

  % \label{fig:sw_architecture}


% \todo[inline]{``Component'' is a quite overloaded concept in Robotics Software Engineering. See
% \cite{brugaliComponent2009,brugaliComponent2010} . Typically it indicates the minimum "block" of computations available in a given robotics framework, for example OROCOS components or ROS Nodes. YARP does not have a real "component", in several aspects both a YARP module or a YARP device could be considered a "Component". Anyhow I don't think we can call this different parts of the libraries "Component".  }

This section describes the current implementation of the whole-body abstraction library conceptually described in Section~\ref{sec:software_architecture}.
The code has been implemented in C++ because of its diffusion and computational performance while remaining a high-level programming language.
The implementation has been divided in two libraries: the \emph{wholeBodyInterface} \cite{wbi} and \emph{yarpWholeBodyInterface} libraries \cite{yarpWBI}.

\subsection{wholeBodyInterface} % (fold)
\label{sub:wholebodyinterface}
The \emph{wholeBodyInterface} is the direct transposition in C++ of the abstract concepts described in Section~\ref{sec:software_architecture}.
The four elements, i.e. \emph{actuators}, \emph{sensors}, \emph{state} and \emph{model}, are represented as abstract classes.
Additionally, the library provides utilities to identify the various degrees of freedom.

As it represents the coded counterpart of the abstraction library, \emph{wholeBodyInterface} does not make any assumption on the underlining robot framework, or how data is organized, using only native C++ types.

% subsection wholebodyinterface (end)

\subsection{yarpWholeBodyInterface} % (fold)
\label{sub:yarpwholebodyinterface}

The \emph{yarpWholeBodyInterface} is the actual implementation of \emph{wholeBodyInterface} specifically considering YARP-powered mechanical systems \cite{metta2006yarp}.
Regarding the \emph{model} implementation we choose as kinematic and dynamic library the iDynTree library \cite{Frontiers2015} and information about the kinematic and dynamic model can be loaded from different sources, e.g. a URDF representation.

The \emph{actuators} and \emph{sensors} elements directly interact with YARP control boards.
Because a robot possesses in general multiple control boards, these two elements are also responsible for mapping the information coming from the control boards to the degrees of freedom selected by the library user.

Note that, because of the dependency on the YARP library, in the current implementation the \emph{state} element uses YARP data structures, e.g. vectors and matrices, but this dependency can be easily dropped in future implementations.

% subsection yarpwholebodyinterface (end)


\subsection{Simulink Interface for Model-Driven Engineering} % (fold)
\label{sub:simulink_interface}

C++ applications can leverage the advantages of the proposed abstraction layer while keeping full control of the performance of the control software by directly using the provided C++ implementations.
On the other hand, coding and testing a complex control system directly in C++ can be prohibitive.
For example, even the simple task of monitoring a signal over time can be complex and requires the use of a dedicated library.
The use of software to design and simulate dynamical system models greatly helps the design and synthesis of control systems. 
Domain-specific software for dynamical systems is a specific case of model-driven engineering \cite{brugali2015}.

We currently implemented the Simulink interface to our proposed whole-body abstraction library, which can be found in \cite{WBToolbox}.
Most of the features accessible in C++ are also accessible to Simulink models.
Furthermore, because the connection with the robot or the simulator is handled by the underlining C++ library, the Simulink interface does not require any particular toolbox to command the robot, e.g. Simulink Real Time\textsuperscript{\textregistered}.


A further advantage of using Simulink\textsuperscript{\textregistered} with respect to the C++ code consists in the possibility to exploit the abundance of toolboxes and Matlab native functions out of the box.

% subsection simulink_interface (end)

% section software_implementation (end)
